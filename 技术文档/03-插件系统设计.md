# 插件系统设计

## 1. 插件系统概述

Chips Viewer 的插件系统允许第三方开发者扩展查看器的功能，特别是添加新的文件查看工具。插件系统设计遵循开放封闭原则，对扩展开放，对修改封闭。

### 1.1 设计目标

1. **易于开发**：提供简洁的 API 和完善的文档
2. **安全隔离**：插件在受控环境中运行，不能危害系统
3. **热插拔**：支持运行时加载、卸载和更新插件
4. **高性能**：最小化插件加载和调用的开销
5. **可发现**：用户能轻松找到和安装插件

### 1.2 插件类型

Chips Viewer 主要支持一种插件类型：

- **查看工具插件 (Viewer Tool Plugin)**：用于查看特定类型文件的工具

## 2. 插件架构

### 2.1 插件系统架构图

```
┌───────────────────────────────────────────────────────┐
│           应用层 (Application Layer)                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  │
│  │ 卡片渲染│  │ 文件查看│  │ 主题应用│  │ 用户界面│  │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘  │
└───────────────────────────────────────────────────────┘
                         ↓
┌───────────────────────────────────────────────────────┐
│        插件管理层 (Plugin Management Layer)            │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│  │ 插件管理器   │  │ 插件调度器   │  │ 插件市场   │ │
│  │ Plugin Mgr   │  │ Dispatcher   │  │ Marketplace │ │
│  └──────────────┘  └──────────────┘  └─────────────┘ │
└───────────────────────────────────────────────────────┘
                         ↓
┌───────────────────────────────────────────────────────┐
│         插件运行时 (Plugin Runtime)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│  │ 插件加载器   │  │ 沙箱环境     │  │ IPC 通信    │ │
│  │ Loader       │  │ Sandbox      │  │             │ │
│  └──────────────┘  └──────────────┘  └─────────────┘ │
└───────────────────────────────────────────────────────┘
                         ↓
┌───────────────────────────────────────────────────────┐
│              插件 (Plugins)                            │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐│
│  │ 视频播放│ │ 音乐播放 │ │ 图片查看 │ │ PDF查看 ││
│  │   器    │ │   器     │ │   器     │ │   器    ││
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘│
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐│
│  │ 代码查看│ │Markdown  │ │ 3D 模型  │ │  自定义 ││
│  │   器    │ │ 渲染器   │ │ 查看器   │ │  插件   ││
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘│
└───────────────────────────────────────────────────────┘
```

### 2.2 核心概念

#### 2.2.1 插件 (Plugin)
一个独立的功能模块，提供特定的查看能力。

#### 2.2.2 插件清单 (Manifest)
插件的元数据文件，描述插件的基本信息、能力和依赖。

#### 2.2.3 插件沙箱 (Sandbox)
插件运行的隔离环境，限制插件的权限和资源访问。

#### 2.2.4 插件 API (Plugin API)
查看器提供给插件的接口，插件通过这些接口与查看器交互。

## 3. 插件清单 (Manifest)

### 3.1 清单结构

每个插件必须包含一个 `manifest.json` 文件：

```json
{
  "id": "com.example.video-player",
  "name": "Advanced Video Player",
  "version": "1.2.0",
  "description": "A professional video player with advanced features",
  "author": {
    "name": "Example Developer",
    "email": "dev@example.com",
    "url": "https://example.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/example/video-player-plugin",
  
  "type": "viewer-tool",
  
  "supportedTypes": [
    "video/mp4",
    "video/webm",
    "video/ogg",
    "video/x-matroska"
  ],
  
  "capabilities": {
    "subtitles": true,
    "multiAudio": true,
    "speedControl": true,
    "frameStep": true,
    "abRepeat": true,
    "videoEffects": true
  },
  
  "main": "dist/index.js",
  "icon": "icon.png",
  "preview": "preview.png",
  
  "dependencies": {
    "video.js": "^8.0.0"
  },
  
  "permissions": [
    "fileSystem.read",
    "network.fetch",
    "storage.local"
  ],
  
  "settings": [
    {
      "key": "defaultPlaybackRate",
      "type": "number",
      "label": "Default Playback Speed",
      "default": 1.0,
      "min": 0.25,
      "max": 2.0,
      "step": 0.25
    },
    {
      "key": "autoplay",
      "type": "boolean",
      "label": "Auto Play",
      "default": false
    },
    {
      "key": "quality",
      "type": "select",
      "label": "Default Quality",
      "default": "auto",
      "options": [
        { "value": "auto", "label": "Auto" },
        { "value": "1080p", "label": "1080p" },
        { "value": "720p", "label": "720p" },
        { "value": "480p", "label": "480p" }
      ]
    }
  ],
  
  "minViewerVersion": "1.0.0",
  "platforms": ["win32", "darwin", "linux", "web"]
}
```

### 3.2 清单字段说明

#### 必需字段

- **id**: 插件的唯一标识符（反向域名格式）
- **name**: 插件的显示名称
- **version**: 插件版本（语义化版本）
- **type**: 插件类型（固定为 `viewer-tool`）
- **supportedTypes**: 支持的 MIME 类型数组
- **main**: 插件入口文件路径

#### 可选字段

- **description**: 插件描述
- **author**: 作者信息
- **license**: 开源协议
- **homepage**: 插件主页
- **icon**: 插件图标
- **preview**: 预览图
- **capabilities**: 插件能力声明
- **dependencies**: 依赖的第三方库
- **permissions**: 需要的权限
- **settings**: 插件设置项
- **minViewerVersion**: 最低查看器版本要求
- **platforms**: 支持的平台

## 4. 插件 API

### 4.1 插件接口定义

```typescript
/**
 * 查看工具插件接口
 */
interface IViewerToolPlugin {
  /**
   * 插件元数据
   */
  readonly manifest: PluginManifest;
  
  /**
   * 初始化插件
   * 在插件加载后调用一次
   */
  init(context: PluginContext): Promise<void>;
  
  /**
   * 销毁插件
   * 在插件卸载前调用
   */
  destroy(): Promise<void>;
  
  /**
   * 检查是否能处理指定文件
   * @param file 文件信息
   * @returns 是否能处理
   */
  canHandle(file: FileInfo): boolean;
  
  /**
   * 渲染文件内容
   * @param file 文件信息
   * @param container 容器元素
   * @param options 渲染选项
   * @returns 渲染结果
   */
  render(
    file: FileInfo,
    container: HTMLElement,
    options?: RenderOptions
  ): Promise<RenderResult>;
  
  /**
   * 释放渲染资源
   */
  dispose(): void;
}

/**
 * 插件上下文
 */
interface PluginContext {
  /**
   * 查看器 API
   */
  viewer: ViewerAPI;
  
  /**
   * 插件配置
   */
  settings: PluginSettings;
  
  /**
   * 插件存储
   */
  storage: PluginStorage;
  
  /**
   * 日志记录器
   */
  logger: Logger;
}

/**
 * 查看器 API
 */
interface ViewerAPI {
  /**
   * 获取当前主题
   */
  getCurrentTheme(): Theme;
  
  /**
   * 订阅事件
   */
  on(event: string, handler: EventHandler): void;
  
  /**
   * 取消订阅
   */
  off(event: string, handler: EventHandler): void;
  
  /**
   * 触发事件
   */
  emit(event: string, data?: any): void;
  
  /**
   * 显示通知
   */
  showNotification(message: string, type?: 'info' | 'success' | 'warning' | 'error'): void;
  
  /**
   * 显示对话框
   */
  showDialog(options: DialogOptions): Promise<DialogResult>;
  
  /**
   * 访问文件系统（需要权限）
   */
  fileSystem: FileSystemAPI;
  
  /**
   * 网络请求（需要权限）
   */
  fetch: typeof fetch;
}

/**
 * 文件信息
 */
interface FileInfo {
  path: string;
  name: string;
  extension: string;
  mimeType: string;
  size: number;
  modifiedTime: number;
  
  /**
   * 读取文件内容
   */
  read(): Promise<ArrayBuffer>;
  
  /**
   * 读取为文本
   */
  readText(encoding?: string): Promise<string>;
  
  /**
   * 读取为 Blob URL
   */
  toBlobURL(): Promise<string>;
}

/**
 * 渲染选项
 */
interface RenderOptions {
  /**
   * 主题
   */
  theme?: Theme;
  
  /**
   * 只读模式
   */
  readonly?: boolean;
  
  /**
   * 自动播放（视频/音频）
   */
  autoplay?: boolean;
  
  /**
   * 自定义参数
   */
  [key: string]: any;
}

/**
 * 渲染结果
 */
interface RenderResult {
  /**
   * 渲染的 DOM 元素
   */
  element: HTMLElement;
  
  /**
   * 控制接口（可选）
   */
  controls?: ViewerControls;
  
  /**
   * 清理函数
   */
  dispose: () => void;
}

/**
 * 查看器控制接口
 */
interface ViewerControls {
  // 播放控制（视频/音频）
  play?(): void;
  pause?(): void;
  stop?(): void;
  seek?(position: number): void;
  setVolume?(volume: number): void;
  setPlaybackRate?(rate: number): void;
  
  // 显示控制
  zoomIn?(): void;
  zoomOut?(): void;
  resetZoom?(): void;
  rotate?(angle: number): void;
  fullscreen?(): void;
  
  // 其他控制
  [key: string]: any;
}
```

### 4.2 插件生命周期

```
插件生命周期：

1. 加载 (Load)
   - 读取 manifest.json
   - 验证插件有效性
   - 检查依赖和权限
   
2. 初始化 (Init)
   - 调用 init() 方法
   - 传递 PluginContext
   - 插件进行初始化设置
   
3. 活跃 (Active)
   - 可以被调用渲染内容
   - 响应查看器事件
   - 处理用户交互
   
4. 销毁 (Destroy)
   - 调用 destroy() 方法
   - 清理资源和事件监听
   - 从内存中移除
```

### 4.3 示例插件实现

```typescript
/**
 * 简单的图片查看器插件示例
 */
export default class SimpleImageViewerPlugin implements IViewerToolPlugin {
  manifest: PluginManifest;
  private context!: PluginContext;
  private currentImage: HTMLImageElement | null = null;
  
  constructor() {
    // manifest 通常从 manifest.json 加载
    this.manifest = {
      id: 'com.example.simple-image-viewer',
      name: 'Simple Image Viewer',
      version: '1.0.0',
      type: 'viewer-tool',
      supportedTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
      main: 'index.js'
    };
  }
  
  async init(context: PluginContext): Promise<void> {
    this.context = context;
    this.context.logger.info('Simple Image Viewer initialized');
    
    // 监听主题变化
    this.context.viewer.on('theme-changed', (theme: Theme) => {
      this.applyTheme(theme);
    });
  }
  
  async destroy(): Promise<void> {
    this.dispose();
    this.context.logger.info('Simple Image Viewer destroyed');
  }
  
  canHandle(file: FileInfo): boolean {
    return this.manifest.supportedTypes!.includes(file.mimeType);
  }
  
  async render(
    file: FileInfo,
    container: HTMLElement,
    options?: RenderOptions
  ): Promise<RenderResult> {
    // 创建容器
    const wrapper = document.createElement('div');
    wrapper.className = 'simple-image-viewer';
    
    // 创建图片元素
    const img = document.createElement('img');
    img.alt = file.name;
    
    // 创建加载指示器
    const loader = document.createElement('div');
    loader.className = 'loader';
    loader.textContent = 'Loading...';
    wrapper.appendChild(loader);
    
    // 加载图片
    const blobURL = await file.toBlobURL();
    img.src = blobURL;
    
    // 等待图片加载
    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
    });
    
    // 移除加载指示器,添加图片
    loader.remove();
    wrapper.appendChild(img);
    
    // 添加控制按钮
    const controls = this.createControls(img);
    wrapper.appendChild(controls);
    
    // 应用主题
    if (options?.theme) {
      this.applyThemeToElement(wrapper, options.theme);
    }
    
    // 添加到容器
    container.appendChild(wrapper);
    
    this.currentImage = img;
    
    // 返回渲染结果
    return {
      element: wrapper,
      controls: {
        zoomIn: () => this.zoom(img, 1.2),
        zoomOut: () => this.zoom(img, 0.8),
        resetZoom: () => this.resetZoom(img),
        rotate: (angle) => this.rotate(img, angle),
        fullscreen: () => this.fullscreen(wrapper)
      },
      dispose: () => this.disposeImage(wrapper, blobURL)
    };
  }
  
  dispose(): void {
    this.currentImage = null;
  }
  
  private createControls(img: HTMLImageElement): HTMLElement {
    const controls = document.createElement('div');
    controls.className = 'image-controls';
    controls.innerHTML = `
      <button data-action="zoom-in" title="放大">+</button>
      <button data-action="zoom-out" title="缩小">-</button>
      <button data-action="reset" title="重置">⟲</button>
      <button data-action="rotate" title="旋转">↻</button>
      <button data-action="fullscreen" title="全屏">⛶</button>
    `;
    
    controls.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const action = target.dataset.action;
      
      switch (action) {
        case 'zoom-in': this.zoom(img, 1.2); break;
        case 'zoom-out': this.zoom(img, 0.8); break;
        case 'reset': this.resetZoom(img); break;
        case 'rotate': this.rotate(img, 90); break;
        case 'fullscreen': this.fullscreen(controls.parentElement!); break;
      }
    });
    
    return controls;
  }
  
  private zoom(img: HTMLImageElement, factor: number): void {
    const currentWidth = img.width || img.naturalWidth;
    img.style.width = `${currentWidth * factor}px`;
  }
  
  private resetZoom(img: HTMLImageElement): void {
    img.style.width = '';
    img.style.transform = '';
  }
  
  private rotate(img: HTMLImageElement, angle: number): void {
    const current = img.dataset.rotation ? parseInt(img.dataset.rotation) : 0;
    const newRotation = (current + angle) % 360;
    img.dataset.rotation = newRotation.toString();
    img.style.transform = `rotate(${newRotation}deg)`;
  }
  
  private fullscreen(element: HTMLElement): void {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    }
  }
  
  private applyTheme(theme: Theme): void {
    if (this.currentImage) {
      const wrapper = this.currentImage.parentElement;
      if (wrapper) {
        this.applyThemeToElement(wrapper, theme);
      }
    }
  }
  
  private applyThemeToElement(element: HTMLElement, theme: Theme): void {
    element.style.backgroundColor = theme.colors.surface;
    element.style.color = theme.colors.text;
  }
  
  private disposeImage(wrapper: HTMLElement, blobURL: string): void {
    URL.revokeObjectURL(blobURL);
    wrapper.remove();
  }
}
```

## 5. 插件管理器

### 5.1 插件管理器实现

```typescript
class PluginManager {
  private plugins: Map<string, LoadedPlugin> = new Map();
  private pluginsByType: Map<string, Set<string>> = new Map();
  private defaultPlugins: Map<string, string> = new Map();
  
  /**
   * 安装插件
   */
  async install(pluginPath: string): Promise<void> {
    // 1. 读取 manifest
    const manifest = await this.readManifest(pluginPath);
    
    // 2. 验证插件
    this.validatePlugin(manifest);
    
    // 3. 检查依赖
    await this.resolveDependencies(manifest);
    
    // 4. 加载插件代码
    const pluginModule = await this.loadPluginCode(pluginPath, manifest.main);
    
    // 5. 创建插件实例
    const plugin = new pluginModule.default();
    
    // 6. 初始化插件
    const context = this.createPluginContext(manifest);
    await plugin.init(context);
    
    // 7. 注册插件
    this.registerPlugin(manifest.id, {
      manifest,
      instance: plugin,
      path: pluginPath,
      context
    });
    
    // 8. 保存配置
    await this.savePluginRegistry();
    
    this.emit('plugin-installed', manifest.id);
  }
  
  /**
   * 卸载插件
   */
  async uninstall(pluginId: string): Promise<void> {
    const loaded = this.plugins.get(pluginId);
    if (!loaded) {
      throw new Error(`Plugin ${pluginId} not found`);
    }
    
    // 1. 调用销毁方法
    await loaded.instance.destroy();
    
    // 2. 从注册表中移除
    this.unregisterPlugin(pluginId);
    
    // 3. 删除插件文件
    await this.deletePluginFiles(loaded.path);
    
    // 4. 保存配置
    await this.savePluginRegistry();
    
    this.emit('plugin-uninstalled', pluginId);
  }
  
  /**
   * 更新插件
   */
  async update(pluginId: string): Promise<void> {
    const loaded = this.plugins.get(pluginId);
    if (!loaded) {
      throw new Error(`Plugin ${pluginId} not found`);
    }
    
    // 1. 检查更新
    const latestVersion = await this.checkUpdate(pluginId);
    if (!latestVersion || latestVersion === loaded.manifest.version) {
      return;
    }
    
    // 2. 下载新版本
    const newPluginPath = await this.downloadPlugin(pluginId, latestVersion);
    
    // 3. 卸载旧版本
    await this.uninstall(pluginId);
    
    // 4. 安装新版本
    await this.install(newPluginPath);
    
    this.emit('plugin-updated', pluginId, latestVersion);
  }
  
  /**
   * 获取插件
   */
  getPlugin(pluginId: string): IViewerToolPlugin | null {
    const loaded = this.plugins.get(pluginId);
    return loaded ? loaded.instance : null;
  }
  
  /**
   * 获取支持指定类型的所有插件
   */
  getPluginsForType(mimeType: string): IViewerToolPlugin[] {
    const pluginIds = this.pluginsByType.get(mimeType);
    if (!pluginIds) {
      return [];
    }
    
    return Array.from(pluginIds)
      .map(id => this.getPlugin(id))
      .filter(p => p !== null) as IViewerToolPlugin[];
  }
  
  /**
   * 设置默认插件
   */
  setDefaultPlugin(mimeType: string, pluginId: string): void {
    this.defaultPlugins.set(mimeType, pluginId);
    this.saveConfig();
  }
  
  /**
   * 获取默认插件
   */
  getDefaultPlugin(mimeType: string): IViewerToolPlugin | null {
    const pluginId = this.defaultPlugins.get(mimeType);
    return pluginId ? this.getPlugin(pluginId) : null;
  }
  
  /**
   * 列出所有插件
   */
  listPlugins(): PluginManifest[] {
    return Array.from(this.plugins.values()).map(p => p.manifest);
  }
  
  // 私有方法...
  
  private async readManifest(pluginPath: string): Promise<PluginManifest> {
    const manifestPath = path.join(pluginPath, 'manifest.json');
    const content = await fs.readFile(manifestPath, 'utf-8');
    return JSON.parse(content);
  }
  
  private validatePlugin(manifest: PluginManifest): void {
    // 验证必需字段
    if (!manifest.id || !manifest.name || !manifest.version || !manifest.main) {
      throw new Error('Invalid plugin manifest: missing required fields');
    }
    
    // 验证版本格式
    if (!/^\d+\.\d+\.\d+$/.test(manifest.version)) {
      throw new Error('Invalid plugin version format');
    }
    
    // 验证 ID 格式
    if (!/^[a-z0-9.-]+$/.test(manifest.id)) {
      throw new Error('Invalid plugin ID format');
    }
  }
  
  private createPluginContext(manifest: PluginManifest): PluginContext {
    return {
      viewer: this.viewerAPI,
      settings: this.loadPluginSettings(manifest.id),
      storage: this.createPluginStorage(manifest.id),
      logger: this.createLogger(manifest.id)
    };
  }
  
  private registerPlugin(pluginId: string, loaded: LoadedPlugin): void {
    this.plugins.set(pluginId, loaded);
    
    // 注册支持的类型
    loaded.manifest.supportedTypes?.forEach(type => {
      if (!this.pluginsByType.has(type)) {
        this.pluginsByType.set(type, new Set());
      }
      this.pluginsByType.get(type)!.add(pluginId);
    });
  }
  
  private unregisterPlugin(pluginId: string): void {
    const loaded = this.plugins.get(pluginId);
    if (!loaded) return;
    
    // 从类型映射中移除
    loaded.manifest.supportedTypes?.forEach(type => {
      this.pluginsByType.get(type)?.delete(pluginId);
    });
    
    this.plugins.delete(pluginId);
  }
}

interface LoadedPlugin {
  manifest: PluginManifest;
  instance: IViewerToolPlugin;
  path: string;
  context: PluginContext;
}
```

### 5.2 插件调度器

```typescript
class PluginDispatcher {
  constructor(private pluginManager: PluginManager) {}
  
  /**
   * 调度插件处理文件
   */
  async dispatch(
    file: FileInfo,
    container: HTMLElement,
    options?: RenderOptions
  ): Promise<RenderResult> {
    // 1. 选择插件
    const plugin = this.selectPlugin(file, options?.preferredPluginId);
    
    if (!plugin) {
      throw new Error(`No plugin found for file type: ${file.mimeType}`);
    }
    
    // 2. 渲染
    try {
      const result = await plugin.render(file, container, options);
      return result;
    } catch (error) {
      // 3. 失败时尝试备用插件
      return this.fallback(file, container, options);
    }
  }
  
  /**
   * 选择插件
   */
  private selectPlugin(file: FileInfo, preferredId?: string): IViewerToolPlugin | null {
    // 1. 如果指定了首选插件，尝试使用
    if (preferredId) {
      const plugin = this.pluginManager.getPlugin(preferredId);
      if (plugin && plugin.canHandle(file)) {
        return plugin;
      }
    }
    
    // 2. 尝试使用默认插件
    const defaultPlugin = this.pluginManager.getDefaultPlugin(file.mimeType);
    if (defaultPlugin && defaultPlugin.canHandle(file)) {
      return defaultPlugin;
    }
    
    // 3. 查找所有支持的插件
    const plugins = this.pluginManager.getPluginsForType(file.mimeType);
    const capable = plugins.filter(p => p.canHandle(file));
    
    if (capable.length > 0) {
      // 返回第一个能处理的插件
      return capable[0];
    }
    
    return null;
  }
  
  /**
   * 备用处理
   */
  private async fallback(
    file: FileInfo,
    container: HTMLElement,
    options?: RenderOptions
  ): Promise<RenderResult> {
    // 使用通用文件查看器
    const genericViewer = this.pluginManager.getPlugin('system.generic-viewer');
    if (genericViewer) {
      return genericViewer.render(file, container, options);
    }
    
    // 显示错误信息
    const errorElement = document.createElement('div');
    errorElement.className = 'viewer-error';
    errorElement.innerHTML = `
      <div class="error-icon">⚠️</div>
      <div class="error-message">无法查看此文件类型</div>
      <div class="error-details">${file.mimeType}</div>
    `;
    container.appendChild(errorElement);
    
    return {
      element: errorElement,
      dispose: () => errorElement.remove()
    };
  }
}
```

## 6. 插件沙箱

### 6.1 沙箱设计

插件在沙箱环境中运行，限制其访问权限：

```typescript
class PluginSandbox {
  private iframe: HTMLIFrameElement | null = null;
  private worker: Worker | null = null;
  
  /**
   * 在沙箱中加载插件
   */
  async loadInSandbox(pluginPath: string, manifest: PluginManifest): Promise<any> {
    // 检查权限
    this.checkPermissions(manifest.permissions || []);
    
    // 创建受限的上下文
    const context = this.createRestrictedContext(manifest);
    
    // 加载插件代码
    const code = await fs.readFile(path.join(pluginPath, manifest.main), 'utf-8');
    
    // 在沙箱中执行
    return this.executeInSandbox(code, context);
  }
  
  /**
   * 创建受限上下文
   */
  private createRestrictedContext(manifest: PluginManifest): any {
    const permissions = new Set(manifest.permissions || []);
    
    return {
      // 只提供白名单中的 API
      console: {
        log: (...args: any[]) => this.safeLog('log', ...args),
        warn: (...args: any[]) => this.safeLog('warn', ...args),
        error: (...args: any[]) => this.safeLog('error', ...args)
      },
      
      // 受限的文件访问
      fileSystem: permissions.has('fileSystem.read') 
        ? this.createFileSystemProxy() 
        : undefined,
      
      // 受限的网络访问
      fetch: permissions.has('network.fetch')
        ? this.createFetchProxy()
        : undefined,
      
      // 受限的存储访问
      storage: permissions.has('storage.local')
        ? this.createStorageProxy()
        : undefined,
      
      // 禁止访问的 API
      eval: undefined,
      Function: undefined,
      XMLHttpRequest: undefined,
      WebSocket: undefined,
      // ... 更多受限 API
    };
  }
  
  /**
   * 在沙箱中执行代码
   */
  private async executeInSandbox(code: string, context: any): Promise<any> {
    // 创建 iframe 沙箱
    this.iframe = document.createElement('iframe');
    this.iframe.sandbox.add('allow-scripts');
    this.iframe.style.display = 'none';
    document.body.appendChild(this.iframe);
    
    const iframeWindow = this.iframe.contentWindow!;
    
    // 注入受限上下文
    Object.keys(context).forEach(key => {
      (iframeWindow as any)[key] = context[key];
    });
    
    // 执行插件代码
    const script = iframeWindow.document.createElement('script');
    script.textContent = code;
    iframeWindow.document.head.appendChild(script);
    
    // 返回插件导出
    return (iframeWindow as any).exports;
  }
  
  /**
   * 清理沙箱
   */
  destroy(): void {
    if (this.iframe) {
      this.iframe.remove();
      this.iframe = null;
    }
    
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
  }
  
  // 代理方法...
  
  private createFileSystemProxy(): any {
    return {
      readFile: async (path: string) => {
        // 检查路径合法性
        if (!this.isPathAllowed(path)) {
          throw new Error('Access denied');
        }
        return fs.readFile(path);
      }
    };
  }
  
  private createFetchProxy(): typeof fetch {
    return async (url: string | Request, init?: RequestInit) => {
      // 检查 URL 合法性
      if (!this.isURLAllowed(url.toString())) {
        throw new Error('Network access denied');
      }
      return fetch(url, init);
    };
  }
  
  private isPathAllowed(path: string): boolean {
    // 只允许访问插件自己的目录和用户数据目录
    return path.startsWith(this.pluginDataDir);
  }
  
  private isURLAllowed(url: string): boolean {
    // 可以配置允许的域名白名单
    return true; // 简化示例
  }
}
```

### 6.2 权限系统

```typescript
/**
 * 插件权限
 */
enum PluginPermission {
  // 文件系统
  FILE_SYSTEM_READ = 'fileSystem.read',
  FILE_SYSTEM_WRITE = 'fileSystem.write',
  
  // 网络
  NETWORK_FETCH = 'network.fetch',
  NETWORK_WEBSOCKET = 'network.websocket',
  
  // 存储
  STORAGE_LOCAL = 'storage.local',
  STORAGE_SYNC = 'storage.sync',
  
  // 系统
  CLIPBOARD = 'clipboard',
  NOTIFICATIONS = 'notifications',
  
  // UI
  DIALOGS = 'dialogs',
  CONTEXT_MENU = 'contextMenu'
}

/**
 * 权限管理器
 */
class PermissionManager {
  private grantedPermissions: Map<string, Set<PluginPermission>> = new Map();
  
  /**
   * 请求权限
   */
  async requestPermissions(
    pluginId: string,
    permissions: PluginPermission[]
  ): Promise<boolean> {
    // 显示权限请求对话框
    const granted = await this.showPermissionDialog(pluginId, permissions);
    
    if (granted) {
      // 记录授予的权限
      const set = this.grantedPermissions.get(pluginId) || new Set();
      permissions.forEach(p => set.add(p));
      this.grantedPermissions.set(pluginId, set);
      
      // 保存权限设置
      await this.savePermissions();
    }
    
    return granted;
  }
  
  /**
   * 检查权限
   */
  hasPermission(pluginId: string, permission: PluginPermission): boolean {
    const permissions = this.grantedPermissions.get(pluginId);
    return permissions ? permissions.has(permission) : false;
  }
  
  /**
   * 撤销权限
   */
  async revokePermissions(pluginId: string, permissions: PluginPermission[]): Promise<void> {
    const set = this.grantedPermissions.get(pluginId);
    if (set) {
      permissions.forEach(p => set.delete(p));
      await this.savePermissions();
    }
  }
}
```

## 7. 插件市场

### 7.1 插件发现和安装

```typescript
class PluginMarketplace {
  private apiEndpoint = 'https://plugins.chips.example.com/api';
  
  /**
   * 搜索插件
   */
  async search(query: string, filters?: SearchFilters): Promise<PluginListing[]> {
    const response = await fetch(`${this.apiEndpoint}/search?q=${query}`, {
      method: 'POST',
      body: JSON.stringify(filters)
    });
    
    return response.json();
  }
  
  /**
   * 获取插件详情
   */
  async getPluginDetails(pluginId: string): Promise<PluginDetails> {
    const response = await fetch(`${this.apiEndpoint}/plugins/${pluginId}`);
    return response.json();
  }
  
  /**
   * 下载插件
   */
  async downloadPlugin(pluginId: string, version: string): Promise<string> {
    const response = await fetch(
      `${this.apiEndpoint}/plugins/${pluginId}/download/${version}`
    );
    
    const blob = await response.blob();
    const arrayBuffer = await blob.arrayBuffer();
    
    // 保存到临时目录
    const tempPath = path.join(os.tmpdir(), `${pluginId}-${version}.zip`);
    await fs.writeFile(tempPath, Buffer.from(arrayBuffer));
    
    // 解压
    const pluginPath = await this.extractPlugin(tempPath);
    
    return pluginPath;
  }
  
  /**
   * 检查更新
   */
  async checkUpdates(installedPlugins: PluginManifest[]): Promise<UpdateInfo[]> {
    const response = await fetch(`${this.apiEndpoint}/updates`, {
      method: 'POST',
      body: JSON.stringify(installedPlugins.map(p => ({
        id: p.id,
        version: p.version
      })))
    });
    
    return response.json();
  }
  
  /**
   * 提交插件（开发者）
   */
  async submitPlugin(pluginPackage: File, apiKey: string): Promise<void> {
    const formData = new FormData();
    formData.append('plugin', pluginPackage);
    formData.append('apiKey', apiKey);
    
    await fetch(`${this.apiEndpoint}/submit`, {
      method: 'POST',
      body: formData
    });
  }
}

interface PluginListing {
  id: string;
  name: string;
  description: string;
  version: string;
  author: string;
  icon: string;
  downloads: number;
  rating: number;
  category: string;
}

interface SearchFilters {
  category?: string;
  platform?: string;
  minRating?: number;
  sortBy?: 'downloads' | 'rating' | 'recent';
}
```

## 8. 插件开发指南

### 8.1 开发环境设置

```bash
# 安装插件开发 CLI
npm install -g @chips/plugin-cli

# 创建新插件
chips-plugin create my-awesome-viewer

# 进入插件目录
cd my-awesome-viewer

# 安装依赖
npm install

# 开发模式（热重载）
npm run dev

# 构建插件
npm run build

# 打包插件
npm run package
```

### 8.2 插件目录结构

```
my-awesome-viewer/
├── manifest.json          # 插件清单
├── package.json           # NPM 包配置
├── tsconfig.json          # TypeScript 配置
├── src/
│   ├── index.ts           # 插件入口
│   ├── viewer.ts          # 查看器实现
│   ├── styles.css         # 样式文件
│   └── utils/             # 工具函数
├── assets/
│   ├── icon.png           # 插件图标
│   └── preview.png        # 预览图
├── dist/                  # 构建输出
│   ├── index.js
│   └── styles.css
├── README.md              # 说明文档
└── LICENSE                # 开源协议
```

### 8.3 调试插件

```typescript
// 插件中使用 logger
export default class MyPlugin implements IViewerToolPlugin {
  private context!: PluginContext;
  
  async init(context: PluginContext): Promise<void> {
    this.context = context;
    
    // 使用 logger
    this.context.logger.info('Plugin initialized');
    this.context.logger.debug('Debug info', { some: 'data' });
    this.context.logger.warn('Warning message');
    this.context.logger.error('Error occurred', error);
  }
}
```

## 9. 总结

Chips Viewer 的插件系统设计提供了：

- **简洁的 API**：易于学习和使用
- **安全的沙箱**：保护用户系统安全
- **完整的生态**：从开发到发布的完整流程
- **灵活的扩展**：支持各种类型的查看工具

通过插件系统，Chips Viewer 可以不断扩展其功能，支持更多文件格式的专业查看，为用户提供最佳的查看体验。

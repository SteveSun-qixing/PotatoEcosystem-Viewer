# Chips Viewer - 架构设计

**版本**: 2.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 架构概述

### 1.1 设计原则

Chips Viewer 的架构设计严格遵循以下核心原则：

1. **中心路由原则** ⭐⭐⭐（最重要）
   - 所有模块间通信都必须经过薯片内核（Chips Core）路由
   - 模块之间绝对禁止直接调用
   - 这是整个架构最核心的设计原则

2. **基于公共基础层**
   - 所有查看工具来自公共基础层（Chips Foundation）
   - 查看器通过路由调用基础层组件
   - 零重复开发，统一维护

3. **插件化优先**
   - 核心功能通过插件实现
   - 查看工具都是插件
   - 支持热插拔和替换

4. **分层解耦**
   - 各层职责清晰
   - 依赖单向（上层依赖下层）
   - 通过接口隔离

5. **前后端分离**
   - 前端只负责界面展示
   - 后端只负责业务逻辑
   - 通过路由通信

### 1.2 架构图

```
┌─────────────────────────────────────────────────────────┐
│                  用户界面层 (UI Layer)                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 工具栏   │  │ 侧边栏   │  │ 内容区域 │  │ 状态栏   │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│           所有通信通过内核路由 ↓                          │
└─────────────────────────────────────────────────────────┘
                          ↓ （路由）
┌─────────────────────────────────────────────────────────┐
│                查看器控制层 (Viewer Layer)                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 导航控制 │  │ 交互控制 │  │ 主题管理 │  │ 布局管理 │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│           所有通信通过内核路由 ↓                          │
└─────────────────────────────────────────────────────────┘
                          ↓ （路由）
┌─────────────────────────────────────────────────────────┐
│              渲染调度层 (Rendering Dispatcher Layer)       │
│  ┌──────────────────────────────────────────────────┐  │
│  │  通过路由调用公共基础层的渲染模块：               │  │
│  │  - CardRenderer（卡片渲染引擎）                   │  │
│  │  - BoxRenderer（箱子渲染引擎）                    │  │
│  │  - ThemeEngine（主题引擎）                        │  │
│  │  Viewer 负责调度、组织和用户交互                  │  │
│  └──────────────────────────────────────────────────┘  │
│           所有通信通过内核路由 ↓                          │
└─────────────────────────────────────────────────────────┘
                          ↓ （路由）
┌─────────────────────────────────────────────────────────┐
│              插件系统层 (Plugin System Layer)              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │插件管理器│  │插件加载器│  │插件调度器│  │插件接口  │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│  ┌──────────────────────────────────────────────────┐  │
│  │        查看工具插件 (Viewer Tool Plugins)         │  │
│  │  视频  音频  图片  代码  PDF  Markdown  文本  ... │  │
│  │  （插件通过路由调用基础层组件）                   │  │
│  └──────────────────────────────────────────────────┘  │
│           所有通信通过内核路由 ↓                          │
└─────────────────────────────────────────────────────────┘
                          ↓ （路由）
┌─────────────────────────────────────────────────────────┐
│               薯片内核层 (Chips Core Layer)                │
│  ┌──────────────────────────────────────────────────┐  │
│  │                 中心路由系统 ⭐⭐⭐                  │  │
│  │  （所有通信的唯一通道，负责路由、验证、转发）      │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │文件解析器│  │插件系统  │  │主题系统  │  │资源管理  │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 事件总线 │  │ 配置管理 │  │ 缓存系统 │  │ 日志系统 │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│           所有通信通过内核路由 ↓                          │
└─────────────────────────────────────────────────────────┘
                          ↓ （路由）
┌─────────────────────────────────────────────────────────┐
│          公共基础层 (Chips Foundation Layer)               │
│  ┌──────────────────────────────────────────────────┐  │
│  │          卡片渲染模块（核心）：                   │  │
│  │  - CardRenderer（卡片渲染引擎）                   │  │
│  │  - BaseCardRenderers（所有26种基础卡片渲染器）    │  │
│  │  - BoxRenderer（箱子渲染引擎）                    │  │
│  │  - ThemeEngine（主题引擎）                        │  │
│  └──────────────────────────────────────────────────┘  │
│  媒体模块：VideoPlayer | AudioPlayer | ImageViewer      │
│  文本模块：RichTextRenderer | MarkdownParser | CodeH... │
│  文件模块：ZIPProcessor | FileIdentifier | Converter    │
│  网络模块：HTTPClient | DownloadManager | CacheManager  │
│  界面模块：UIControls | WindowManager | DragDropSystem  │
│  系统模块：DataSerializer | LogSystem | I18nSystem ...  │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│             平台适配层 (Platform Adaptation Layer)         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │  Electron │  │Capacitor │  │   Web    │  │  Native  │ │
│  │ (桌面端)  │  │ (移动端)  │  │ (浏览器)  │  │  (原生)  │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 微内核路由架构 ⭐⭐⭐

### 2.1 核心原则

**最重要的架构原则**：所有模块间通信都必须经过薯片内核路由

**严格要求**：
```typescript
// ✅ 正确：通过内核路由
const response = await Core.request({
  service: 'foundation.video.play',
  payload: { video_uri: 'chips://card/abc123/video.mp4' }
});

// ❌ 错误：直接调用（绝对禁止！）
import { VideoPlayer } from '@chips/foundation';
const player = new VideoPlayer();  // 禁止！
```

**为什么这么重要**：
1. **完全解耦**：模块之间互不依赖，可以随时替换
2. **权限控制**：内核统一验证所有调用的权限
3. **日志记录**：所有通信都可以记录和监控
4. **版本兼容**：内核负责版本适配和协议转换
5. **错误处理**：统一的错误捕获和处理机制

### 2.2 路由工作流程

```
用户操作（如打开视频卡片）
    ↓
UI Layer 捕获事件
    ↓
向内核发送请求：Core.request({
  service: 'card.open',
  payload: { card_id: 'abc123' }
})
    ↓
内核接收请求：
  1. 验证请求格式
  2. 检查权限
  3. 查找路由表
  4. 找到目标模块
    ↓
内核路由到卡片管理模块
    ↓
卡片管理模块解析卡片
    ↓
返回卡片数据给内核
    ↓
内核转发给查看器
    ↓
查看器识别需要视频播放器
    ↓
向内核发送请求：Core.request({
  service: 'plugin.get_handler',
  payload: { mime_type: 'video/mp4' }
})
    ↓
内核返回插件列表
    ↓
查看器选择插件
    ↓
向内核发送请求：Core.request({
  service: 'plugin.invoke',
  payload: {
    plugin_id: 'chipshub:video-player',
    method: 'render',
    params: { ... }
  }
})
    ↓
内核路由到插件
    ↓
插件向内核发送请求：Core.request({
  service: 'foundation.video.create_player',
  payload: { video_uri: '...', options: { ... } }
})
    ↓
内核路由到基础层
    ↓
基础层创建播放器组件
    ↓
返回播放器实例给内核
    ↓
内核转发给插件
    ↓
插件将播放器显示在界面上
    ↓
用户看到视频播放器
```

### 2.3 路由表示例

内核维护完整的路由表：

```typescript
const routeTable = {
  // 卡片管理服务
  'card.open': {
    module: 'card-manager',
    handler: 'CardManager.openCard',
    permissions: ['card.read']
  },
  'card.read': {
    module: 'card-manager',
    handler: 'CardManager.readCard',
    permissions: ['card.read']
  },
  
  // 基础层服务
  'foundation.video.create_player': {
    module: 'foundation',
    handler: 'VideoPlayer.create',
    permissions: ['foundation.use']
  },
  'foundation.audio.create_player': {
    module: 'foundation',
    handler: 'AudioPlayer.create',
    permissions: ['foundation.use']
  },
  
  // 插件服务
  'plugin.install': {
    module: 'plugin-manager',
    handler: 'PluginManager.install',
    permissions: ['plugin.install']
  },
  'plugin.invoke': {
    module: 'plugin-manager',
    handler: 'PluginManager.invoke',
    permissions: ['plugin.use']
  },
  
  // 主题服务
  'theme.apply': {
    module: 'theme-manager',
    handler: 'ThemeManager.apply',
    permissions: ['theme.use']
  },
  
  // 资源服务
  'resource.fetch': {
    module: 'resource-manager',
    handler: 'ResourceManager.fetch',
    permissions: ['resource.read']
  }
  
  // ... 更多路由
};
```

### 2.4 请求和响应格式

**请求格式**：
```typescript
interface Request {
  service: string;      // 服务名称，格式：module.method
  payload: any;         // 请求参数
  options?: {
    timeout?: number;   // 超时时间（毫秒）
    priority?: 'high' | 'normal' | 'low';  // 优先级
    retry?: number;     // 重试次数
  };
}
```

**响应格式**：
```typescript
interface Response {
  success: boolean;     // 是否成功
  data?: any;          // 返回数据
  error?: {
    code: string;      // 错误代码
    message: string;   // 错误消息
    details?: any;     // 错误详情
  };
  metadata?: {
    duration: number;  // 处理时间（毫秒）
    timestamp: number; // 时间戳
  };
}
```

**使用示例**：
```typescript
try {
  const response = await Core.request({
    service: 'foundation.video.create_player',
    payload: {
      video_uri: 'chips://card/abc123/video.mp4',
      container_id: 'player-container',
      options: {
        controls: true,
        autoplay: false
      }
    },
    options: {
      timeout: 5000,
      priority: 'high'
    }
  });
  
  if (response.success) {
    const player = response.data.player;
    // 使用播放器
  } else {
    // 处理错误
    console.error(response.error);
  }
} catch (error) {
  // 处理异常
}
```

---

## 3. 公共基础层集成

### 3.1 基础层的作用

公共基础层（Chips Foundation）提供所有通用功能模块：

- **媒体模块**：VideoPlayer、AudioPlayer、ImageViewer、Model3DRenderer
- **文本模块**：RichTextRenderer、MarkdownParser、CodeHighlighter、TextEditor
- **文件模块**：ZIPProcessor、FileIdentifier、FormatConverter
- **网络模块**：HTTPClient、DownloadManager、CacheManager、ProtocolAdapter
- **界面模块**：UIControls、WindowManager、DragDropSystem、IFrameWrapper
- **系统模块**：DataSerializer、LogSystem、I18nSystem、ConfigManager

**查看器通过路由调用这些组件，不需要自己实现**。

### 3.2 调用基础层组件

**所有调用都通过路由**：

```typescript
// 创建视频播放器
const videoPlayerResponse = await Core.request({
  service: 'foundation.video.create_player',
  payload: {
    video_uri: 'chips://card/abc123/video.mp4',
    container_id: 'player-container',
    options: {
      controls: true,
      autoplay: false,
      poster: 'chips://card/abc123/poster.jpg'
    }
  }
});
const videoPlayer = videoPlayerResponse.data.player;

// 创建音频播放器
const audioPlayerResponse = await Core.request({
  service: 'foundation.audio.create_player',
  payload: {
    audio_uri: 'chips://card/abc123/audio.mp3',
    container_id: 'player-container',
    options: {
      controls: true,
      visualizer: 'waveform'
    }
  }
});
const audioPlayer = audioPlayerResponse.data.player;

// 创建图片查看器
const imageViewerResponse = await Core.request({
  service: 'foundation.image.create_viewer',
  payload: {
    image_uri: 'chips://card/abc123/image.jpg',
    container_id: 'viewer-container',
    options: {
      zoom: true,
      rotation: true
    }
  }
});
const imageViewer = imageViewerResponse.data.viewer;

// 渲染 Markdown
const markdownResponse = await Core.request({
  service: 'foundation.markdown.render',
  payload: {
    markdown_text: cardContent,
    container_id: 'content-area',
    options: {
      enable_gfm: true,
      enable_math: true
    }
  }
});

// 代码高亮
const codeResponse = await Core.request({
  service: 'foundation.code.highlight',
  payload: {
    code_content: codeText,
    language: 'typescript',
    container_id: 'code-area',
    options: {
      theme: 'vs-dark',
      line_numbers: true
    }
  }
});
```

### 3.3 基础层组件的生命周期

```typescript
// 1. 创建组件
const createResponse = await Core.request({
  service: 'foundation.video.create_player',
  payload: { /* ... */ }
});
const player = createResponse.data.player;

// 2. 使用组件
// 播放控制通过组件实例提供的方法
player.play();
player.pause();
player.seek(100);

// 3. 监听事件
player.on('timeupdate', (currentTime) => {
  // 更新进度条
});
player.on('ended', () => {
  // 播放结束
});

// 4. 销毁组件
await Core.request({
  service: 'foundation.video.destroy_player',
  payload: {
    player_id: player.id
  }
});
```

---

## 4. 分层架构详解

### 4.1 平台适配层 (Platform Adaptation Layer)

**职责**：
- 封装不同平台的差异
- 提供统一的系统 API 接口
- 处理平台特定的功能和限制

**组件**：
- Electron 适配器（桌面端）
- Capacitor 适配器（移动端）
- Web 适配器（浏览器）
- Native 适配器（原生应用）

**接口示例**：
```typescript
interface IPlatformAdapter {
  // 文件系统
  readFile(path: string): Promise<ArrayBuffer>;
  writeFile(path: string, data: ArrayBuffer): Promise<void>;
  listDirectory(path: string): Promise<FileInfo[]>;
  
  // 系统功能
  showNotification(title: string, body: string): void;
  openExternal(url: string): void;
  showDialog(options: DialogOptions): Promise<DialogResult>;
  
  // 平台信息
  getPlatform(): 'desktop' | 'mobile' | 'web';
  getVersion(): string;
}
```

### 4.2 薯片内核层 (Chips Core Layer)

**职责**：
- 提供中心路由系统（最核心）
- 管理插件生命周期
- 处理文件解析和序列化
- 提供主题和资源管理

**核心模块**：

#### 4.2.1 中心路由系统
```typescript
class CoreRouter {
  // 注册服务
  register(route: string, handler: RouteHandler): void;
  
  // 路由请求
  async route(request: Request): Promise<Response>;
  
  // 广播事件
  broadcast(event: Event): void;
  
  // 查询路由
  getRoutes(pattern?: string): Route[];
}
```

#### 4.2.2 文件解析器
```typescript
class CardParser {
  async parse(data: ArrayBuffer): Promise<Card>;
  validate(card: Card): ValidationResult;
  getMetadata(data: ArrayBuffer): CardMetadata;
}

class BoxParser {
  async parse(directory: string): Promise<Box>;
  getConfig(directory: string): BoxConfig;
  scanCards(directory: string): Card[];
}
```

#### 4.2.3 插件系统
```typescript
class PluginManager {
  async loadPlugin(pluginId: string): Promise<Plugin>;
  unloadPlugin(pluginId: string): void;
  getPlugin(pluginId: string): Plugin | null;
  listPlugins(filter?: PluginFilter): Plugin[];
}
```

#### 4.2.4 资源管理
```typescript
class ResourceManager {
  async loadResource(uri: string): Promise<Resource>;
  cacheResource(uri: string, data: ArrayBuffer): void;
  clearCache(pattern?: string): void;
  getCacheStatistics(): CacheStats;
}
```

### 4.3 公共基础层 (Chips Foundation Layer)

**职责**：
- 提供所有通用功能模块
- 提供查看工具组件
- 提供界面组件和系统服务

**模块分类**：
- 媒体模块（8 个组件）
- 文本模块（4 个组件）
- 文件模块（3 个组件）
- 网络模块（4 个组件）
- 界面模块（4 个组件）
- 系统模块（4 个组件）

详见 [公共基础层使用指南](./02-公共基础层使用指南.md)。

### 4.4 插件系统层 (Plugin System Layer)

**职责**：
- 管理查看工具插件的生命周期
- 根据文件类型调度合适的插件
- 提供插件间通信机制

**组件**：

#### 4.4.1 插件管理器
```typescript
class ViewerPluginManager {
  // 插件生命周期
  async install(plugin: ViewerPlugin): Promise<void>;
  async uninstall(pluginId: string): Promise<void>;
  async update(pluginId: string): Promise<void>;
  
  // 插件查询
  getPluginForType(mimeType: string): ViewerPlugin | null;
  listPluginsForType(mimeType: string): ViewerPlugin[];
  getAllPlugins(): ViewerPlugin[];
  
  // 默认工具管理
  setDefaultPlugin(mimeType: string, pluginId: string): void;
  getDefaultPlugin(mimeType: string): ViewerPlugin | null;
}
```

#### 4.4.2 插件调度器
```typescript
class PluginDispatcher {
  async dispatch(file: File, container: HTMLElement): Promise<void>;
  selectPlugin(file: File, preferredId?: string): ViewerPlugin;
  fallback(file: File): ViewerPlugin;
}
```

#### 4.4.3 插件接口
```typescript
interface IViewerPlugin {
  id: string;
  name: string;
  version: string;
  supportedTypes: string[]; // MIME types
  
  // 生命周期
  init(): Promise<void>;
  destroy(): void;
  
  // 渲染
  canHandle(file: File): boolean;
  render(file: File, container: HTMLElement, options?: RenderOptions): Promise<void>;
  dispose(): void;
  
  // 控制
  play?(): void;
  pause?(): void;
  stop?(): void;
  seek?(position: number): void;
  
  // 事件
  on(event: string, handler: Function): void;
  off(event: string, handler: Function): void;
}
```

### 4.5 渲染调度层 (Rendering Dispatcher Layer)

**职责**：
- **通过路由调用公共基础层的渲染模块**（CardRenderer、BoxRenderer、ThemeEngine）
- **不自己实现渲染逻辑**，只负责调度和组织
- 接收渲染结果（iframe 窗口）并显示
- 管理渲染状态和生命周期

**核心原则** ⭐⭐⭐：
- **渲染逻辑在公共基础层**，Viewer 只调用
- **所有调用通过微内核路由**
- Viewer 负责**窗口管理、导航控制、用户交互**

**组件**：

#### 4.5.1 卡片渲染调度器
```typescript
class CardRenderingDispatcher {
  // 调用基础层的 CardRenderer
  async renderCard(cardId: string, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    // 通过路由请求 CardRenderer（公共基础层）
    const response = await Core.request({
      service: 'foundation.card.render',
      payload: {
        card_id: cardId,
        container_id: container.id,
        options: {
          theme_id: options?.themeId,
          interactive: options?.interactive ?? true,
          readonly: true
        }
      }
    });
    
    // 返回渲染结果（iframe 窗口）
    return response.data;
  }
  
  // 管理渲染状态
  trackRendering(cardId: string, result: RenderResult): void;
  disposeRendering(cardId: string): void;
}
```

#### 4.5.2 箱子渲染调度器
```typescript
class BoxRenderingDispatcher {
  // 调用基础层的 BoxRenderer
  async renderBox(boxId: string, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    // 通过路由请求 BoxRenderer（公共基础层）
    const response = await Core.request({
      service: 'foundation.box.render',
      payload: {
        box_id: boxId,
        container_id: container.id,
        options: {
          theme_id: options?.themeId,
          interactive: true
        }
      }
    });
    
    // 返回渲染结果（iframe 窗口）
    return response.data;
  }
  
  // 处理用户点击卡片项
  async handleCardClick(cardId: string): Promise<void> {
    await this.renderCard(cardId);
  }
}
```

#### 4.5.3 主题管理器
```typescript
class ThemeManager {
  // 调用基础层的 ThemeEngine
  async applyTheme(themeId: string, scope: 'global' | 'card', targetId?: string): Promise<void> {
    await Core.request({
      service: 'foundation.theme.apply',
      payload: {
        theme_id: themeId,
        scope: scope,
        target_id: targetId
      }
    });
  }
  
  // 获取当前主题
  getCurrentTheme(): Theme;
  // 管理主题切换
  switchTheme(themeId: string): void;
}
```

### 4.6 查看器控制层 (Viewer Layer)

**职责**：
- 管理查看器的交互逻辑
- 处理用户输入和导航
- 控制界面状态

**组件**：

#### 4.6.1 导航控制器
```typescript
class NavigationController {
  navigate(target: NavigationTarget): void;
  back(): void;
  forward(): void;
  goToCard(cardId: string): void;
  getHistory(): NavigationHistory;
}
```

#### 4.6.2 交互控制器
```typescript
class InteractionController {
  handleClick(event: MouseEvent): void;
  handleKeyboard(event: KeyboardEvent): void;
  handleTouch(event: TouchEvent): void;
  handleScroll(event: ScrollEvent): void;
}
```

### 4.7 用户界面层 (UI Layer)

**职责**：
- 渲染用户界面
- 响应用户操作
- 显示状态和反馈

**组件**：
- 工具栏（Toolbar）
- 侧边栏（Sidebar）
- 内容区域（Content Area）
- 状态栏（Status Bar）

---

## 5. 数据流

### 5.1 文件打开流程

```
用户双击 .card 文件
    ↓
平台适配层捕获文件打开事件
    ↓
传递文件路径给内核（通过路由）
    ↓
内核的文件解析器解析卡片文件
    ↓
返回 Card 对象给查看器（通过路由）
    ↓
查看器的渲染引擎识别卡片类型
    ↓
查看器通过路由请求插件调度器选择插件
    ↓
插件调度器选择合适的查看工具插件（通过路由）
    ↓
查看器通过路由调用插件的渲染方法
    ↓
插件通过路由请求基础层的组件
    ↓
基础层创建组件并返回（通过路由）
    ↓
插件将组件显示在界面
    ↓
用户看到渲染后的卡片
```

### 5.2 插件调用流程

```
渲染引擎需要渲染特定文件（如 video.mp4）
    ↓
通过路由请求内核：查找支持 video/mp4 的插件
    ↓
内核查询插件注册表，返回插件列表（通过路由）
    ↓
渲染引擎选择用户设置的默认插件
    ↓
通过路由请求内核：加载插件（如未加载）
    ↓
内核加载插件并返回插件实例（通过路由）
    ↓
通过路由调用插件的 render() 方法
    ↓
插件通过路由请求基础层：创建视频播放器
    ↓
基础层创建播放器并返回（通过路由）
    ↓
插件将播放器显示在界面
    ↓
用户与播放器交互
    ↓
插件处理交互并更新界面
```

### 5.3 主题切换流程

```
用户在设置中选择新主题
    ↓
UI Layer 通过路由请求内核：切换主题
    ↓
内核通过路由请求主题管理器：加载主题数据
    ↓
主题管理器返回主题数据（通过路由）
    ↓
内核通过路由请求渲染引擎：应用主题
    ↓
渲染引擎的主题应用器将主题应用到界面
    ↓
更新 CSS 变量和样式
    ↓
触发重新渲染（如需要）
    ↓
内核通过路由请求配置管理器：保存用户的主题偏好
    ↓
界面以新主题显示
```

---

## 6. 模块依赖关系

### 6.1 依赖图

```
UI Layer
  ├── depends on → Viewer Layer（通过路由）
  └── depends on → Chips Core Layer（通过路由）

Viewer Layer
  ├── depends on → Rendering Layer（通过路由）
  ├── depends on → Plugin System Layer（通过路由）
  └── depends on → Chips Core Layer（通过路由）

Rendering Layer
  ├── depends on → Plugin System Layer（通过路由）
  └── depends on → Chips Core Layer（通过路由）

Plugin System Layer
  └── depends on → Chips Core Layer（通过路由）

Chips Core Layer
  ├── depends on → Chips Foundation Layer（通过路由）
  └── depends on → Platform Adaptation Layer（通过路由）

Chips Foundation Layer
  └── depends on → Platform Adaptation Layer

Platform Adaptation Layer
  └── 系统 API
```

### 6.2 依赖原则

1. **单向依赖**：上层依赖下层，下层不依赖上层
2. **通过路由依赖**：所有依赖通过内核路由，不直接引用
3. **接口隔离**：通过接口而非具体实现依赖
4. **最小依赖**：只依赖必需的模块

### 6.3 禁止的依赖

```typescript
// ❌ 禁止：UI Layer 直接调用 Foundation
import { VideoPlayer } from '@chips/foundation';
const player = new VideoPlayer();

// ❌ 禁止：Plugin 直接调用 Rendering Layer
import { CardRenderer } from '@chips/viewer/rendering';
const renderer = new CardRenderer();

// ❌ 禁止：任何模块直接调用其他模块
import { SomeModule } from '@chips/other-module';
SomeModule.doSomething();

// ✅ 正确：所有调用通过路由
const response = await Core.request({
  service: 'module.method',
  payload: { /* ... */ }
});
```

---

## 7. 性能优化策略

### 7.1 渲染优化

- **虚拟滚动**：只渲染可见区域的内容
- **增量渲染**：分批渲染大量内容
- **懒加载**：延迟加载非关键资源
- **防抖节流**：优化频繁触发的操作

### 7.2 资源管理

- **智能缓存**：缓存常用资源和渲染结果
- **资源池**：重用对象，减少创建销毁开销
- **按需加载**：只加载当前需要的插件和资源
- **预加载**：预测性加载即将需要的资源

### 7.3 路由优化

- **批量请求**：合并多个请求减少往返
- **请求缓存**：缓存路由结果
- **异步处理**：使用异步消息避免阻塞
- **优先级队列**：高优先级请求优先处理

---

## 8. 安全性设计

### 8.1 插件沙箱

- 插件在隔离环境中运行
- 限制插件的系统访问权限
- 插件通信通过受控接口（路由）

### 8.2 输入验证

- 验证所有用户输入
- 防止 XSS 和注入攻击
- 严格的文件格式验证

### 8.3 资源访问控制

- 限制文件系统访问范围
- 网络请求白名单机制
- 敏感操作需要用户确认

---

## 9. 总结

Chips Viewer 的架构设计体现了以下核心特点：

1. **严格的中心路由原则** ⭐⭐⭐
   - 所有通信通过内核路由
   - 模块完全解耦
   - 统一的权限和日志管理

2. **基于公共基础层**
   - 零重复开发
   - 统一维护和升级
   - 共享生态基础设施

3. **清晰的分层架构**
   - 职责明确
   - 单向依赖
   - 易于理解和维护

4. **高度的可扩展性**
   - 插件化设计
   - 模块可替换
   - 开放的生态系统

通过这样的架构设计，Chips Viewer 实现了高性能、高可靠性、高可维护性的目标，为用户提供优秀的卡片查看体验。

---

**文档维护者**：Chips 生态团队  
**审核状态**：✅ 已审核  
**下一步**：阅读[公共基础层使用指南](./02-公共基础层使用指南.md)了解如何调用基础层组件

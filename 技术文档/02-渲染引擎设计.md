# 卡片渲染模块调用指南

## 1. 渲染机制概述

**核心原则** ⭐⭐⭐：
- **卡片渲染的完整逻辑在公共基础层**（CardRenderer、BaseCardRenderers、BoxRenderer、ThemeEngine）
- **Viewer 通过路由调用这些模块**，不自己实现渲染逻辑
- **渲染流程**：渲染器读取卡片配置 → 调用基础卡片插件的前端代码 → 填充内容数据 → 生成 iframe
- **每个基础卡片一个 iframe**，多个 iframe 垂直排列组合成完整卡片
- **最终交付一个大 iframe 窗口**（菜单栏 + 基础卡片 iframes + 主题背景）

### 1.1 架构说明

```
查看器（Viewer）
    ↓ （通过路由调用）
公共基础层（Chips Foundation）
    ├── CardRenderer（卡片渲染引擎）
    │   ├── 解析卡片文件结构
    │   ├── 遍历基础卡片列表
    │   ├── 调用 BaseCardRenderers
    │   ├── 组合 iframe 窗口
    │   └── 应用主题（ThemeEngine）
    ├── BaseCardRenderers（26种基础卡片渲染器）
    │   ├── 调用基础卡片插件的前端代码
    │   ├── 填充内容数据到模板
    │   └── 生成 iframe 窗口
    ├── BoxRenderer（箱子渲染引擎）
    │   ├── 解析箱子文件结构
    │   ├── 加载布局插件
    │   └── 生成箱子展示界面
    └── ThemeEngine（主题引擎）
        ├── 加载主题包
        ├── 处理原子级主题配置
        └── 应用样式到组件
```

### 1.2 查看器的职责

Viewer **不负责**：
- ❌ 解析卡片文件结构
- ❌ 实现基础卡片的渲染逻辑
- ❌ 生成 iframe 窗口
- ❌ 应用主题样式

Viewer **负责**：
- ✅ 通过路由调用 CardRenderer/BoxRenderer
- ✅ 接收渲染结果（iframe 窗口）
- ✅ 将 iframe 嵌入到界面中
- ✅ 提供窗口管理（最小化、全屏、分屏）
- ✅ 提供导航控制（前进后退、面包屑）
- ✅ 提供用户交互扩展（收藏、搜索）

## 2. 调用 CardRenderer 渲染卡片

### 2.1 基本调用方式

```typescript
// 在 Viewer 中调用 CardRenderer
class ViewerCardManager {
  async openCard(cardId: string, container: HTMLElement): Promise<void> {
    try {
      // 通过路由请求 CardRenderer（公共基础层）
      const response = await Core.request({
        service: 'foundation.card.render',
        payload: {
          card_id: cardId,
          container_id: container.id,
          options: {
            theme_id: this.getCurrentTheme(),
            interactive: true,
            readonly: true
          }
        }
      });
      
      if (response.success) {
        // 获取渲染结果（iframe 窗口）
        const cardFrame = response.data.frame;
        
        // 将 iframe 嵌入到容器中
        container.appendChild(cardFrame);
        
        // 记录渲染状态
        this.trackRendering(cardId, cardFrame);
        
        // 更新导航历史
        this.navigationService.push({ cardId, timestamp: Date.now() });
      } else {
        // 处理错误
        this.showError(response.error.message);
      }
    } catch (error) {
      console.error('Failed to render card:', error);
      this.showError('卡片渲染失败');
    }
  }
  
  private getCurrentTheme(): string {
    return this.themeService.getActiveThemeId();
  }
  
  private trackRendering(cardId: string, frame: HTMLIFrameElement): void {
    this.renderingTracker.set(cardId, {
      frame,
      timestamp: Date.now(),
      dispose: () => frame.remove()
    });
  }
}
```

### 2.2 CardRenderer 的渲染流程（由公共基础层处理）

**Viewer 不需要关心这些细节**，这些都由 CardRenderer 自动处理：

```
1. 解析卡片文件
   - 读取 .card/metadata.yaml
   - 读取 .card/structure.yaml（基础卡片列表）
   - 读取 content/ 目录下的配置文件

2. 遍历基础卡片列表
   - 按 structure.yaml 中的顺序处理

3. 渲染每个基础卡片
   - 根据 type 字段选择对应的 BaseCardRenderer
   - BaseCardRenderer 调用基础卡片插件的前端代码
   - 将配置数据填充到前端模板
   - 生成 iframe 窗口

4. 组合所有 iframe
   - 垂直排列所有基础卡片的 iframe
   - 设置 iframe 背景为透明
   - 添加菜单栏（卡片名称、操作按钮）

5. 应用主题
   - 通过 ThemeEngine 加载主题包
   - 将主题作为整体背景网页
   - 应用原子级主题配置

6. 返回结果
   - 返回完整的大 iframe 窗口
   - Viewer 直接显示这个 iframe
```

### 2.3 渲染选项说明

```typescript
interface CardRenderOptions {
  // 主题 ID（格式：发行商:主题名）
  theme_id?: string;
  
  // 是否启用交互（默认 true）
  interactive?: boolean;
  
  // 是否只读模式（默认 true，Viewer 中不能编辑）
  readonly?: boolean;
  
  // 渲染质量（默认 'high'）
  quality?: 'low' | 'medium' | 'high';
  
  // 是否启用懒加载（默认 true）
  lazy_load?: boolean;
  
  // 是否启用虚拟滚动（默认 true，大卡片自动启用）
  virtual_scroll?: boolean;
}
```

## 3. 调用 BoxRenderer 渲染箱子

### 3.1 基本调用方式

```typescript
// 在 Viewer 中调用 BoxRenderer
class ViewerBoxManager {
  async openBox(boxId: string, container: HTMLElement): Promise<void> {
    try {
      // 通过路由请求 BoxRenderer（公共基础层）
      const response = await Core.request({
        service: 'foundation.box.render',
        payload: {
          box_id: boxId,
          container_id: container.id,
          options: {
            theme_id: this.getCurrentTheme(),
            interactive: true
          }
        }
      });
      
      if (response.success) {
        // 获取渲染结果（iframe 窗口）
        const boxFrame = response.data.frame;
        
        // 将 iframe 嵌入到容器中
        container.appendChild(boxFrame);
        
        // 监听卡片点击事件
        this.setupBoxInteraction(boxFrame, boxId);
        
        // 记录渲染状态
        this.trackRendering(boxId, boxFrame);
      } else {
        this.showError(response.error.message);
      }
    } catch (error) {
      console.error('Failed to render box:', error);
      this.showError('箱子渲染失败');
    }
  }
  
  private setupBoxInteraction(boxFrame: HTMLIFrameElement, boxId: string): void {
    // 监听 iframe 内的卡片点击事件
    // 当用户点击某个卡片项时，调用 CardRenderer 渲染该卡片
    boxFrame.contentWindow?.addEventListener('cardClick', (event: CustomEvent) => {
      const cardId = event.detail.cardId;
      this.viewerCardManager.openCard(cardId, this.cardViewerContainer);
    });
  }
}
```

### 3.2 BoxRenderer 的渲染流程（由公共基础层处理）

**Viewer 不需要关心这些细节**，这些都由 BoxRenderer 自动处理：

```
1. 解析箱子文件
   - 读取 .box/metadata.yaml
   - 读取 .box/structure.yaml（卡片列表）
   - 读取 .box/content.yaml（布局配置）

2. 识别布局类型
   - 从配置中获取布局类型（grid、waterfall、list、kanban 等）

3. 加载布局插件
   - 根据布局类型加载对应的布局插件
   - 布局插件包含完整的前端代码

4. 调用布局插件
   - 将卡片列表和配置传递给布局插件
   - 布局插件生成展示界面（HTML + CSS + JS）

5. 生成 iframe 窗口
   - 将布局插件生成的网页包装在 iframe 中
   - 设置交互事件（卡片点击等）

6. 返回结果
   - 返回完整的 iframe 窗口
   - Viewer 显示这个 iframe
```

### 3.3 箱子渲染选项说明

```typescript
interface BoxRenderOptions {
  // 主题 ID
  theme_id?: string;
  
  // 是否启用交互（默认 true）
  interactive?: boolean;
  
  // 是否加载外部引用的卡片（默认 false）
  load_external?: boolean;
  
  // 是否启用虚拟滚动（大量卡片时自动启用）
  virtual_scroll?: boolean;
  
  // 自定义布局配置（覆盖箱子默认配置）
  layout_config?: {
    columns?: number;
    gap?: number;
    sort_by?: 'name' | 'date' | 'size';
    sort_order?: 'asc' | 'desc';
  };
}
```

## 4. 调用 ThemeEngine 管理主题

### 4.1 应用主题

```typescript
// 在 Viewer 中管理主题
class ViewerThemeManager {
  async applyTheme(themeId: string, scope: 'global' | 'card', targetId?: string): Promise<void> {
    try {
      // 通过路由请求 ThemeEngine（公共基础层）
      const response = await Core.request({
        service: 'foundation.theme.apply',
        payload: {
          theme_id: themeId,  // 格式：发行商:主题名
          scope: scope,
          target_id: targetId,  // 如果 scope 是 'card'，需要提供卡片 ID
        }
      });
      
      if (response.success) {
        // 更新本地主题状态
        if (scope === 'global') {
          this.currentTheme = themeId;
          this.saveThemePreference(themeId);
        }
        
        // 通知其他组件主题已更新
        this.eventBus.emit('theme-changed', { themeId, scope });
      } else {
        this.showError('主题应用失败');
      }
    } catch (error) {
      console.error('Failed to apply theme:', error);
    }
  }
  
  // 获取可用主题列表
  async getAvailableThemes(): Promise<Theme[]> {
    const response = await Core.request({
      service: 'foundation.theme.list',
      payload: {}
    });
    
    return response.data.themes;
  }
  
  // 跟随系统主题
  enableAutoTheme(): void {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    
    const updateTheme = () => {
      const themeId = mediaQuery.matches ? 'chipshub:dark' : 'chipshub:light';
      this.applyTheme(themeId, 'global');
    };
    
    mediaQuery.addEventListener('change', updateTheme);
    updateTheme();
  }
}
```

### 4.2 ThemeEngine 的工作流程（由公共基础层处理）

**Viewer 不需要关心这些细节**，这些都由 ThemeEngine 自动处理：

```
1. 加载主题包
   - 解析主题包结构
   - 读取主题配置和样式文件
   - 注册主题到主题注册表

2. 应用主题
   - 根据主题标识查找主题包
   - 根据 scope 确定应用范围
   - 如果是卡片级主题，查找对应卡片

3. 处理主题层级
   - 从组件主题、卡片主题、应用主题、全局主题依次查找
   - 使用最高优先级的主题
   - 如果某层级为空，自动使用上一层级主题

4. 注入样式
   - 提取对应组件类型的样式代码
   - 将样式注入到组件的渲染结果
   - 更新 CSS 变量和样式类
```

## 5. Viewer 的渲染相关职责总结

### 5.1 Viewer 负责的部分

1. **调用渲染模块**
   - 通过路由调用 CardRenderer/BoxRenderer/ThemeEngine
   - 传递正确的参数和选项
   - 处理渲染结果

2. **窗口管理**
   - 接收 iframe 窗口并嵌入到界面
   - 管理窗口状态（最小化、全屏、分屏）
   - 处理窗口的创建和销毁

3. **导航控制**
   - 维护浏览历史（前进/后退）
   - 提供面包屑导航
   - 管理卡片树形结构侧边栏

4. **用户交互扩展**
   - 提供收藏功能
   - 提供搜索功能
   - 提供导出和分享功能
   - 处理键盘快捷键和手势

5. **状态管理**
   - 跟踪当前打开的卡片/箱子
   - 管理主题偏好设置
   - 保存用户配置和历史记录

### 5.2 Viewer 不负责的部分

1. **渲染逻辑**
   - ❌ 不实现卡片/箱子的渲染逻辑
   - ❌ 不实现基础卡片的渲染器
   - ❌ 不实现主题样式的应用
   - ❌ 不实现布局算法

2. **文件解析**
   - ❌ 不解析 .card 或 .box 文件结构
   - ❌ 不读取配置文件
   - ❌ 不处理 ZIP 压缩

3. **插件管理**（基础卡片插件）
   - ❌ 不加载基础卡片插件
   - ❌ 不调用插件的前端代码
   - ❌ 不管理插件生命周期

**这些都由公共基础层的模块处理。**

### 5.3 调用示例总结

```typescript
// Viewer 的典型使用流程
class ChipsViewer {
  private cardManager: ViewerCardManager;
  private boxManager: ViewerBoxManager;
  private themeManager: ViewerThemeManager;
  
  async openFile(filePath: string): Promise<void> {
    // 1. 识别文件类型
    const fileType = await this.identifyFile(filePath);
    
    if (fileType === 'card') {
      // 2. 调用 CardRenderer
      await this.cardManager.openCard(filePath, this.contentArea);
    } else if (fileType === 'box') {
      // 2. 调用 BoxRenderer
      await this.boxManager.openBox(filePath, this.contentArea);
    }
    
    // 3. 更新界面状态
    this.updateNavigation(filePath);
    this.updateTitle(filePath);
  }
  
  async switchTheme(themeId: string): Promise<void> {
    // 调用 ThemeEngine
    await this.themeManager.applyTheme(themeId, 'global');
  }
}
```

## 6. 性能考虑

### 6.1 Viewer 层面的优化

虽然渲染逻辑在公共基础层,但 Viewer 仍需注意性能:

1. **iframe 管理**
   - 限制同时打开的卡片数量
   - 及时销毁不再使用的 iframe
   - 使用虚拟列表管理历史记录

2. **内存管理**
   - 监控内存使用
   - 清理不活跃的渲染实例
   - 合理设置缓存大小

3. **响应性能**
   - 使用防抖/节流优化频繁操作
   - 异步加载非关键功能
   - 提供加载状态反馈

### 6.2 基础层的优化（自动提供）

CardRenderer/BoxRenderer/ThemeEngine 自动提供:

- 虚拟滚动（大卡片/箱子）
- 懒加载（图片、视频等资源）
- 增量渲染（分批渲染内容）
- 渲染缓存（缓存已渲染结果）
- 硬件加速（CSS transforms、WebGL）

## 7. 总结

Chips Viewer 的渲染机制基于**职责分离**的原则:

- **公共基础层**：负责所有渲染逻辑
  - CardRenderer：解析卡片、调用插件、生成 iframe
  - BaseCardRenderers：渲染 26 种基础卡片
  - BoxRenderer：渲染箱子展示
  - ThemeEngine：管理和应用主题

- **查看器（Viewer）**：负责产品功能
  - 调用渲染模块（通过路由）
  - 窗口管理和导航控制
  - 用户交互和状态管理

这种设计确保了:
1. **代码复用**：所有产品使用相同的渲染逻辑
2. **一致性**：不同产品中的卡片显示效果完全一致
3. **灵活性**：开发者可以在任意产品中集成卡片查看能力
4. **轻量化**：Viewer 保持轻量,不包含复杂的渲染逻辑

---

**文档维护者**：Chips 生态团队  
**审核状态**：✅ 已审核  
**相关文档**：
- [架构设计](./01-架构设计.md)
- [公共基础层设计](../../生态设计原稿（一切标准）/32-公共基础层设计.md)
- [卡片渲染机制详解](../../生态设计原稿（一切标准）/33-卡片渲染机制详解.md)
  
  constructor() {
    this.marked = marked.setOptions({
      gfm: true,
      breaks: true,
      highlight: (code, lang) => this.highlighter.highlight(code, lang)
    });
  }
  
  render(card: MarkdownCard, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    // 解析 Markdown
    const html = this.marked.parse(card.content);
    
    // 处理数学公式
    const htmlWithMath = this.renderMath(html);
    
    // 创建元素
    const element = document.createElement('div');
    element.className = 'card-markdown';
    element.innerHTML = htmlWithMath;
    
    // 生成目录
    if (card.showToc) {
      const toc = this.generateToc(element);
      element.prepend(toc);
    }
    
    // 应用主题
    if (options?.theme) {
      this.applyTheme(element, options.theme);
    }
    
    container.appendChild(element);
    
    return {
      element,
      dispose: () => element.remove(),
      update: (updates) => this.updateMarkdown(element, updates)
    };
  }
  
  private renderMath(html: string): string {
    // 使用 KaTeX 渲染数学公式
    return html.replace(/\$\$(.+?)\$\$/g, (match, formula) => {
      return katex.renderToString(formula, { displayMode: true });
    });
  }
  
  private generateToc(element: HTMLElement): HTMLElement {
    // 提取所有标题，生成目录
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const toc = document.createElement('nav');
    toc.className = 'markdown-toc';
    // ... 生成目录结构
    return toc;
  }
}
```

#### 3.2.3 图片卡片渲染器

```typescript
class ImageCardRenderer implements ICardRenderer {
  render(card: ImageCard, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    const wrapper = document.createElement('div');
    wrapper.className = 'card-image';
    
    const img = document.createElement('img');
    img.src = card.url;
    img.alt = card.alt || '';
    
    // 加载状态
    const placeholder = this.createPlaceholder();
    wrapper.appendChild(placeholder);
    
    // 图片加载
    return new Promise((resolve) => {
      img.onload = () => {
        placeholder.remove();
        wrapper.appendChild(img);
        
        // 添加交互控件
        if (options?.interactive) {
          this.addImageControls(wrapper, img);
        }
        
        container.appendChild(wrapper);
        
        resolve({
          element: wrapper,
          dispose: () => wrapper.remove(),
          update: (updates) => this.updateImage(img, updates)
        });
      };
      
      img.onerror = () => {
        placeholder.innerHTML = '图片加载失败';
        container.appendChild(wrapper);
        resolve({
          element: wrapper,
          dispose: () => wrapper.remove(),
          update: () => {}
        });
      };
    });
  }
  
  private createPlaceholder(): HTMLElement {
    const placeholder = document.createElement('div');
    placeholder.className = 'image-placeholder';
    placeholder.innerHTML = '<div class="spinner"></div>';
    return placeholder;
  }
  
  private addImageControls(wrapper: HTMLElement, img: HTMLImageElement): void {
    // 添加缩放、旋转等控件
    const controls = document.createElement('div');
    controls.className = 'image-controls';
    controls.innerHTML = `
      <button data-action="zoom-in">+</button>
      <button data-action="zoom-out">-</button>
      <button data-action="rotate">↻</button>
      <button data-action="fullscreen">⛶</button>
    `;
    
    controls.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const action = target.dataset.action;
      
      switch (action) {
        case 'zoom-in': this.zoomIn(img); break;
        case 'zoom-out': this.zoomOut(img); break;
        case 'rotate': this.rotate(img); break;
        case 'fullscreen': this.fullscreen(wrapper); break;
      }
    });
    
    wrapper.appendChild(controls);
  }
}
```

#### 3.2.4 代码卡片渲染器

```typescript
class CodeCardRenderer implements ICardRenderer {
  private highlighter: Prism | HighlightJS;
  
  render(card: CodeCard, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    const wrapper = document.createElement('div');
    wrapper.className = 'card-code';
    
    // 创建代码块
    const pre = document.createElement('pre');
    const code = document.createElement('code');
    code.className = `language-${card.language}`;
    code.textContent = card.content;
    
    // 语法高亮
    this.highlighter.highlightElement(code);
    
    // 行号
    if (card.showLineNumbers) {
      this.addLineNumbers(pre, code);
    }
    
    pre.appendChild(code);
    wrapper.appendChild(pre);
    
    // 工具栏
    const toolbar = this.createCodeToolbar(card);
    wrapper.appendChild(toolbar);
    
    // 应用主题
    if (options?.theme) {
      this.applyCodeTheme(wrapper, options.theme);
    }
    
    container.appendChild(wrapper);
    
    return {
      element: wrapper,
      dispose: () => wrapper.remove(),
      update: (updates) => this.updateCode(code, updates)
    };
  }
  
  private createCodeToolbar(card: CodeCard): HTMLElement {
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    toolbar.innerHTML = `
      <span class="language-label">${card.language}</span>
      <button class="copy-button" title="复制代码">
        <svg><!-- 复制图标 --></svg>
      </button>
    `;
    
    toolbar.querySelector('.copy-button')?.addEventListener('click', () => {
      navigator.clipboard.writeText(card.content);
      this.showCopyFeedback(toolbar);
    });
    
    return toolbar;
  }
  
  private addLineNumbers(pre: HTMLElement, code: HTMLElement): void {
    const lines = code.textContent!.split('\n').length;
    const lineNumbers = document.createElement('span');
    lineNumbers.className = 'line-numbers';
    lineNumbers.innerHTML = Array.from({ length: lines }, (_, i) => i + 1).join('\n');
    pre.insertBefore(lineNumbers, code);
  }
}
```

### 3.3 复合卡片渲染

#### 3.3.1 复合卡片渲染器

```typescript
class CompositeCardRenderer implements ICardRenderer {
  private rendererFactory: RendererFactory;
  
  async render(card: CompositeCard, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    const wrapper = document.createElement('div');
    wrapper.className = 'card-composite';
    wrapper.dataset.cardId = card.id;
    
    // 应用布局
    const layout = card.layout || 'vertical';
    wrapper.classList.add(`layout-${layout}`);
    
    // 渲染所有子卡片
    const childResults: RenderResult[] = [];
    for (const childCard of card.children) {
      const renderer = this.rendererFactory.getRenderer(childCard.type);
      const childContainer = document.createElement('div');
      childContainer.className = 'card-child';
      
      const result = await renderer.render(childCard, childContainer, options);
      childResults.push(result);
      wrapper.appendChild(childContainer);
    }
    
    // 应用主题
    if (options?.theme) {
      this.applyTheme(wrapper, options.theme);
    }
    
    container.appendChild(wrapper);
    
    return {
      element: wrapper,
      dispose: () => {
        childResults.forEach(r => r.dispose());
        wrapper.remove();
      },
      update: (updates) => this.updateComposite(wrapper, updates, childResults)
    };
  }
  
  private async updateComposite(
    wrapper: HTMLElement,
    updates: Partial<CompositeCard>,
    childResults: RenderResult[]
  ): Promise<void> {
    // 更新布局
    if (updates.layout) {
      wrapper.className = wrapper.className.replace(/layout-\w+/, `layout-${updates.layout}`);
    }
    
    // 更新子卡片
    if (updates.children) {
      // 比较新旧子卡片，智能更新
      // 只更新变化的部分
    }
  }
}
```

### 3.4 渲染器工厂

```typescript
class RendererFactory {
  private renderers: Map<CardType, ICardRenderer> = new Map();
  
  constructor() {
    this.registerDefaultRenderers();
  }
  
  private registerDefaultRenderers(): void {
    this.register('richtext', new RichTextCardRenderer());
    this.register('markdown', new MarkdownCardRenderer());
    this.register('image', new ImageCardRenderer());
    this.register('video', new VideoCardRenderer());
    this.register('audio', new AudioCardRenderer());
    this.register('code', new CodeCardRenderer());
    this.register('list', new ListCardRenderer());
    this.register('rating', new RatingCardRenderer());
    this.register('web', new WebCardRenderer());
    this.register('composite', new CompositeCardRenderer(this));
  }
  
  register(type: CardType, renderer: ICardRenderer): void {
    this.renderers.set(type, renderer);
  }
  
  getRenderer(type: CardType): ICardRenderer {
    const renderer = this.renderers.get(type);
    if (!renderer) {
      throw new Error(`No renderer registered for card type: ${type}`);
    }
    return renderer;
  }
}
```

## 4. 主题系统

### 4.1 主题数据结构

```typescript
interface Theme {
  id: string;
  name: string;
  version: string;
  
  colors: {
    // 基础颜色
    primary: string;
    secondary: string;
    background: string;
    surface: string;
    text: string;
    textSecondary: string;
    border: string;
    
    // 语义颜色
    success: string;
    warning: string;
    error: string;
    info: string;
  };
  
  typography: {
    fontFamily: string;
    fontSize: {
      base: string;
      small: string;
      large: string;
      heading: {
        h1: string;
        h2: string;
        h3: string;
        h4: string;
        h5: string;
        h6: string;
      };
    };
    lineHeight: {
      normal: number;
      loose: number;
      tight: number;
    };
  };
  
  spacing: {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
  };
  
  borderRadius: {
    small: string;
    medium: string;
    large: string;
  };
  
  shadows: {
    small: string;
    medium: string;
    large: string;
  };
  
  // 特定卡片类型的样式
  cardStyles: {
    [cardType: string]: CardThemeStyle;
  };
  
  // 代码高亮主题
  codeTheme: string; // 如 'vs-code', 'monokai'
}

interface CardThemeStyle {
  background?: string;
  padding?: string;
  border?: string;
  borderRadius?: string;
  shadow?: string;
  [key: string]: any;
}
```

### 4.2 主题应用器

```typescript
class ThemeApplier {
  apply(theme: Theme, target: HTMLElement): void {
    // 设置 CSS 变量
    this.setCSSVariables(target, theme);
    
    // 添加主题类名
    target.classList.add(`theme-${theme.id}`);
    
    // 应用特定样式
    this.applySpecificStyles(target, theme);
  }
  
  private setCSSVariables(target: HTMLElement, theme: Theme): void {
    const root = target;
    
    // 颜色变量
    Object.entries(theme.colors).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value);
    });
    
    // 字体变量
    root.style.setProperty('--font-family', theme.typography.fontFamily);
    root.style.setProperty('--font-size-base', theme.typography.fontSize.base);
    // ... 更多变量
    
    // 间距变量
    Object.entries(theme.spacing).forEach(([key, value]) => {
      root.style.setProperty(`--spacing-${key}`, value);
    });
    
    // 圆角变量
    Object.entries(theme.borderRadius).forEach(([key, value]) => {
      root.style.setProperty(`--border-radius-${key}`, value);
    });
  }
  
  private applySpecificStyles(target: HTMLElement, theme: Theme): void {
    // 为不同卡片类型应用特定样式
    const cards = target.querySelectorAll('[data-card-type]');
    cards.forEach((card) => {
      const cardType = card.getAttribute('data-card-type');
      if (cardType && theme.cardStyles[cardType]) {
        this.applyCardStyle(card as HTMLElement, theme.cardStyles[cardType]);
      }
    });
  }
  
  private applyCardStyle(element: HTMLElement, style: CardThemeStyle): void {
    Object.entries(style).forEach(([property, value]) => {
      const cssProperty = this.camelToKebab(property);
      element.style.setProperty(cssProperty, value);
    });
  }
  
  private camelToKebab(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
  
  remove(target: HTMLElement): void {
    // 移除主题类名
    target.className = target.className.replace(/theme-\w+/g, '').trim();
    
    // 清除 CSS 变量
    // （可选，也可以保留让新主题覆盖）
  }
}
```

### 4.3 内置主题

```typescript
// 简洁白主题
const LightTheme: Theme = {
  id: 'light',
  name: '简洁白',
  version: '1.0.0',
  colors: {
    primary: '#1976d2',
    secondary: '#424242',
    background: '#ffffff',
    surface: '#f5f5f5',
    text: '#212121',
    textSecondary: '#757575',
    border: '#e0e0e0',
    success: '#4caf50',
    warning: '#ff9800',
    error: '#f44336',
    info: '#2196f3'
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    fontSize: {
      base: '16px',
      small: '14px',
      large: '18px',
      heading: {
        h1: '32px',
        h2: '28px',
        h3: '24px',
        h4: '20px',
        h5: '18px',
        h6: '16px'
      }
    },
    lineHeight: {
      normal: 1.5,
      loose: 1.8,
      tight: 1.2
    }
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px'
  },
  borderRadius: {
    small: '4px',
    medium: '8px',
    large: '12px'
  },
  shadows: {
    small: '0 1px 3px rgba(0,0,0,0.12)',
    medium: '0 3px 6px rgba(0,0,0,0.16)',
    large: '0 10px 20px rgba(0,0,0,0.19)'
  },
  cardStyles: {},
  codeTheme: 'vs-code'
};

// 深邃黑主题
const DarkTheme: Theme = {
  ...LightTheme,
  id: 'dark',
  name: '深邃黑',
  colors: {
    primary: '#90caf9',
    secondary: '#ce93d8',
    background: '#121212',
    surface: '#1e1e1e',
    text: '#ffffff',
    textSecondary: '#b0b0b0',
    border: '#333333',
    success: '#81c784',
    warning: '#ffb74d',
    error: '#e57373',
    info: '#64b5f6'
  },
  codeTheme: 'dracula'
};
```

## 5. 布局引擎

### 5.1 布局系统

```typescript
interface LayoutEngine {
  calculate(items: LayoutItem[], constraints: LayoutConstraints): Layout;
  apply(layout: Layout, container: HTMLElement): void;
}

interface LayoutItem {
  id: string;
  element: HTMLElement;
  minWidth?: number;
  minHeight?: number;
  aspectRatio?: number;
}

interface LayoutConstraints {
  containerWidth: number;
  containerHeight: number;
  columns?: number;
  gap?: number;
  padding?: number;
}

interface Layout {
  items: LayoutItemPosition[];
  totalHeight: number;
}

interface LayoutItemPosition {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
}
```

### 5.2 布局算法

#### 5.2.1 网格布局

```typescript
class GridLayoutEngine implements LayoutEngine {
  calculate(items: LayoutItem[], constraints: LayoutConstraints): Layout {
    const { containerWidth, columns = 3, gap = 16, padding = 16 } = constraints;
    
    const availableWidth = containerWidth - padding * 2 - gap * (columns - 1);
    const itemWidth = availableWidth / columns;
    
    const positions: LayoutItemPosition[] = [];
    const columnHeights = new Array(columns).fill(padding);
    
    items.forEach((item, index) => {
      const column = index % columns;
      const x = padding + column * (itemWidth + gap);
      const y = columnHeights[column];
      
      // 计算高度（保持宽高比或使用默认）
      const height = item.aspectRatio 
        ? itemWidth / item.aspectRatio 
        : item.minHeight || 200;
      
      positions.push({
        id: item.id,
        x,
        y,
        width: itemWidth,
        height
      });
      
      columnHeights[column] += height + gap;
    });
    
    return {
      items: positions,
      totalHeight: Math.max(...columnHeights) + padding
    };
  }
  
  apply(layout: Layout, container: HTMLElement): void {
    container.style.position = 'relative';
    container.style.height = `${layout.totalHeight}px`;
    
    layout.items.forEach(pos => {
      const element = container.querySelector(`[data-id="${pos.id}"]`) as HTMLElement;
      if (element) {
        element.style.position = 'absolute';
        element.style.left = `${pos.x}px`;
        element.style.top = `${pos.y}px`;
        element.style.width = `${pos.width}px`;
        element.style.height = `${pos.height}px`;
      }
    });
  }
}
```

#### 5.2.2 瀑布流布局

```typescript
class WaterfallLayoutEngine implements LayoutEngine {
  calculate(items: LayoutItem[], constraints: LayoutConstraints): Layout {
    const { containerWidth, columns = 3, gap = 16, padding = 16 } = constraints;
    
    const availableWidth = containerWidth - padding * 2 - gap * (columns - 1);
    const itemWidth = availableWidth / columns;
    
    const positions: LayoutItemPosition[] = [];
    const columnHeights = new Array(columns).fill(padding);
    
    items.forEach(item => {
      // 找到最短的列
      const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));
      
      const x = padding + shortestColumn * (itemWidth + gap);
      const y = columnHeights[shortestColumn];
      
      // 计算高度
      const height = item.aspectRatio 
        ? itemWidth / item.aspectRatio 
        : item.minHeight || 200;
      
      positions.push({
        id: item.id,
        x,
        y,
        width: itemWidth,
        height
      });
      
      columnHeights[shortestColumn] += height + gap;
    });
    
    return {
      items: positions,
      totalHeight: Math.max(...columnHeights) + padding
    };
  }
  
  apply(layout: Layout, container: HTMLElement): void {
    // 同网格布局的 apply 方法
  }
}
```

### 5.3 响应式设计

```typescript
class ResponsiveLayoutManager {
  private breakpoints = {
    mobile: 480,
    tablet: 768,
    desktop: 1024,
    wide: 1440
  };
  
  getLayoutConfig(width: number): LayoutConstraints {
    if (width < this.breakpoints.mobile) {
      return { containerWidth: width, columns: 1, gap: 8, padding: 8 };
    } else if (width < this.breakpoints.tablet) {
      return { containerWidth: width, columns: 2, gap: 12, padding: 12 };
    } else if (width < this.breakpoints.desktop) {
      return { containerWidth: width, columns: 3, gap: 16, padding: 16 };
    } else if (width < this.breakpoints.wide) {
      return { containerWidth: width, columns: 4, gap: 20, padding: 20 };
    } else {
      return { containerWidth: width, columns: 5, gap: 24, padding: 24 };
    }
  }
  
  observeResize(container: HTMLElement, callback: (width: number) => void): ResizeObserver {
    const observer = new ResizeObserver(entries => {
      const entry = entries[0];
      callback(entry.contentRect.width);
    });
    
    observer.observe(container);
    return observer;
  }
}
```

## 6. 性能优化

### 6.1 虚拟滚动

```typescript
class VirtualScroller {
  private viewport: HTMLElement;
  private content: HTMLElement;
  private items: any[];
  private itemHeight: number;
  private visibleCount: number;
  private startIndex: number = 0;
  
  constructor(viewport: HTMLElement, items: any[], itemHeight: number) {
    this.viewport = viewport;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(viewport.clientHeight / itemHeight) + 2; // 缓冲
    
    this.content = document.createElement('div');
    this.content.style.height = `${items.length * itemHeight}px`;
    this.viewport.appendChild(this.content);
    
    this.viewport.addEventListener('scroll', () => this.onScroll());
    this.render();
  }
  
  private onScroll(): void {
    const scrollTop = this.viewport.scrollTop;
    const newStartIndex = Math.floor(scrollTop / this.itemHeight);
    
    if (newStartIndex !== this.startIndex) {
      this.startIndex = newStartIndex;
      this.render();
    }
  }
  
  private render(): void {
    const endIndex = Math.min(this.startIndex + this.visibleCount, this.items.length);
    const visibleItems = this.items.slice(this.startIndex, endIndex);
    
    this.content.innerHTML = '';
    
    visibleItems.forEach((item, index) => {
      const element = this.renderItem(item);
      element.style.position = 'absolute';
      element.style.top = `${(this.startIndex + index) * this.itemHeight}px`;
      this.content.appendChild(element);
    });
  }
  
  private renderItem(item: any): HTMLElement {
    // 渲染单个项目
    const element = document.createElement('div');
    element.textContent = item.toString();
    return element;
  }
}
```

### 6.2 懒加载

```typescript
class LazyLoader {
  private observer: IntersectionObserver;
  
  constructor(options?: IntersectionObserverInit) {
    this.observer = new IntersectionObserver(
      (entries) => this.onIntersect(entries),
      options || { rootMargin: '100px' }
    );
  }
  
  observe(element: HTMLElement, loadCallback: () => void): void {
    element.dataset.lazy = 'true';
    element.dataset.loadCallback = 'pending';
    
    (element as any)._lazyLoadCallback = loadCallback;
    
    this.observer.observe(element);
  }
  
  private onIntersect(entries: IntersectionObserverEntry[]): void {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const element = entry.target as HTMLElement;
        const callback = (element as any)._lazyLoadCallback;
        
        if (callback && element.dataset.loadCallback === 'pending') {
          element.dataset.loadCallback = 'loading';
          callback();
          element.dataset.loadCallback = 'loaded';
          this.observer.unobserve(element);
        }
      }
    });
  }
  
  disconnect(): void {
    this.observer.disconnect();
  }
}
```

### 6.3 增量渲染

```typescript
class IncrementalRenderer {
  private renderQueue: Array<() => void> = [];
  private isRendering: boolean = false;
  
  enqueue(renderFn: () => void): void {
    this.renderQueue.push(renderFn);
    
    if (!this.isRendering) {
      this.processQueue();
    }
  }
  
  private processQueue(): void {
    if (this.renderQueue.length === 0) {
      this.isRendering = false;
      return;
    }
    
    this.isRendering = true;
    
    // 使用 requestIdleCallback 在浏览器空闲时渲染
    requestIdleCallback((deadline) => {
      while (deadline.timeRemaining() > 0 && this.renderQueue.length > 0) {
        const renderFn = this.renderQueue.shift()!;
        renderFn();
      }
      
      this.processQueue();
    });
  }
}
```

### 6.4 缓存机制

```typescript
class RenderCache {
  private cache: Map<string, CachedRender> = new Map();
  private maxSize: number = 100;
  
  get(key: string): HTMLElement | null {
    const cached = this.cache.get(key);
    
    if (cached && !this.isExpired(cached)) {
      cached.lastAccess = Date.now();
      return cached.element.cloneNode(true) as HTMLElement;
    }
    
    return null;
  }
  
  set(key: string, element: HTMLElement, ttl: number = 60000): void {
    // 检查缓存大小
    if (this.cache.size >= this.maxSize) {
      this.evict();
    }
    
    this.cache.set(key, {
      element: element.cloneNode(true) as HTMLElement,
      timestamp: Date.now(),
      lastAccess: Date.now(),
      ttl
    });
  }
  
  private isExpired(cached: CachedRender): boolean {
    return Date.now() - cached.timestamp > cached.ttl;
  }
  
  private evict(): void {
    // LRU 淘汰策略
    let oldestKey: string | null = null;
    let oldestTime = Infinity;
    
    this.cache.forEach((value, key) => {
      if (value.lastAccess < oldestTime) {
        oldestTime = value.lastAccess;
        oldestKey = key;
      }
    });
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }
  
  clear(): void {
    this.cache.clear();
  }
}

interface CachedRender {
  element: HTMLElement;
  timestamp: number;
  lastAccess: number;
  ttl: number;
}
```

## 7. 总结

Chips Viewer 的渲染引擎通过模块化的设计、完善的主题系统和多种性能优化策略，实现了高效、美观、可扩展的卡片渲染能力。渲染引擎是查看器的核心，它确保用户能够流畅地查看各种类型的卡片内容，并享受一致的视觉体验。

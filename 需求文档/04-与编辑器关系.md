# 与编辑器关系

## 1. 关系概述

Chips Viewer（查看器）和 Chips Editor（编辑引擎）是 Chips 生态中两个独立但又紧密相关的产品。它们的关系采用**双轨并行**的设计策略，既提供独立的查看器产品，又在编辑器中内置完整的查看模式。

## 2. 双轨设计

### 2.1 设计理念

**为什么需要双轨设计？**

1. **用户需求多样化**
   - 有些用户只需要查看内容，不需要编辑功能
   - 有些用户需要频繁在查看和编辑之间切换
   - 不同场景对软件体积和性能有不同要求

2. **性能和资源考虑**
   - 独立查看器可以做得更轻量、启动更快
   - 编辑器功能完整但体积较大
   - 用户可以根据需求选择合适的工具

3. **使用场景不同**
   - 快速浏览：使用轻量级查看器
   - 内容创作：使用完整编辑器
   - 内容审阅：在编辑器中切换到查看模式

### 2.2 双轨架构

```
Chips 生态
├── 独立查看器产品 (Chips Viewer)
│   ├── 轻量级独立应用
│   ├── 只包含查看相关功能
│   └── 快速启动、低资源占用
│
└── 编辑器的查看模式 (Editor View Mode)
    ├── 编辑器内置功能
    ├── 完整的查看能力
    └── 通过"锁定"按钮切换
```

## 3. 独立查看器产品

### 3.1 产品定位

**Chips Viewer** 是一个独立的可执行应用程序，专门用于查看卡片和箱子内容。

### 3.2 特点

1. **轻量级**
   - 安装包体积：50-100MB
   - 内存占用：空闲时 < 200MB
   - 启动时间：< 2 秒

2. **专注查看**
   - 不包含任何编辑功能
   - 不包含卡片创建功能
   - 专注于内容展示和交互式浏览

3. **完整的查看能力**
   - 支持所有卡片类型的查看
   - 包含完整的查看工具插件系统
   - 支持主题应用和自定义

4. **独立运行**
   - 不依赖编辑器
   - 可单独安装和分发
   - 适合只需要查看功能的用户

### 3.3 适用场景

- **内容分享**：将查看器和卡片一起分享给他人
- **移动端**：在手机/平板上查看卡片
- **轻量使用**：只需要查看，不需要编辑
- **系统资源有限**：低配设备上使用
- **企业部署**：为团队部署只读查看工具

### 3.4 文件关联

独立查看器可以作为 `.card` 文件的默认打开程序：

- **Windows**：双击 .card 文件用查看器打开
- **macOS**：设置查看器为 .card 文件的默认应用
- **Linux**：配置 MIME 类型关联
- **Mobile**：注册为 .card 文件的处理应用

## 4. 编辑器的查看模式

### 4.1 功能定位

编辑器的查看模式是编辑器内置的一个完整的查看功能模块，让用户可以在编辑器中快速切换到只读查看状态。

### 4.2 特点

1. **无缝切换**
   - 点击"锁定"按钮即可进入查看模式
   - 查看模式下禁用所有编辑功能
   - 可以快速切换回编辑模式

2. **完整功能**
   - 查看功能与独立查看器完全一致
   - 使用相同的渲染引擎和插件系统
   - 支持所有查看器的功能和设置

3. **集成优势**
   - 不需要启动额外的应用程序
   - 在同一个窗口中工作
   - 共享编辑器的配置和插件

4. **性能权衡**
   - 编辑器本身较大，启动较慢
   - 但切换到查看模式无需重新加载
   - 适合需要频繁查看和编辑的场景

### 4.3 适用场景

- **内容创作时预览**：编辑后立即查看效果
- **审阅修订**：以查看模式审阅内容，决定是否修改
- **演示内容**：使用查看模式展示卡片，不担心误编辑
- **学习参考**：查看示例卡片，需要时切换到编辑模式学习

### 4.4 切换机制

#### 4.4.1 进入查看模式

**触发方式**：
- 点击工具栏的"锁定"按钮（🔒）
- 快捷键：`Ctrl+Shift+L`（Lock）
- 菜单：视图 → 查看模式

**行为**：
- 立即禁用所有编辑功能
- 工具栏切换为查看模式工具栏
- 界面调整为查看优化布局
- 光标变为浏览模式

#### 4.4.2 退出查看模式

**触发方式**：
- 再次点击"解锁"按钮（🔓）
- 快捷键：`Ctrl+Shift+L`
- 尝试编辑时自动提示切换

**行为**：
- 恢复编辑功能
- 工具栏切换为编辑模式工具栏
- 恢复编辑模式布局
- 光标恢复为编辑模式

#### 4.4.3 状态持久化

- 记住上次使用的模式（查看/编辑）
- 下次打开同一卡片时恢复状态
- 可以设置默认打开模式

## 5. 共享架构

### 5.1 共享的核心组件

独立查看器和编辑器的查看模式共享以下核心组件：

#### 5.1.1 渲染引擎
- **共享代码**：卡片渲染的核心逻辑
- **一致性**：确保两者显示效果完全一致
- **维护性**：只需维护一套渲染代码

#### 5.1.2 插件系统
- **兼容性**：查看工具插件可以在两者中使用
- **共享插件库**：安装的插件对两者都可用
- **统一接口**：插件开发者只需适配一套接口

#### 5.1.3 主题系统
- **共享主题**：主题在两者间通用
- **同步设置**：主题偏好可以同步
- **一致体验**：用户看到相同的视觉效果

### 5.2 独立的组件

#### 5.2.1 独立查看器特有
- **轻量级启动器**：快速启动模块
- **简化的 UI**：专注查看的界面
- **性能优化**：针对查看场景的优化

#### 5.2.2 编辑器特有
- **编辑功能模块**：所有编辑相关功能
- **编辑工具栏**：编辑相关的 UI 控件
- **数据修改逻辑**：修改和保存卡片的逻辑

### 5.3 薯片内核

两者都基于统一的薯片内核（Chips Core）：

```
薯片内核 (Chips Core)
├── 文件解析和序列化
├── 插件管理系统
├── 主题系统
├── 资源管理
└── 路由和通信

         ↓ 调用

  ┌──────────────┬──────────────┐
  │              │              │
独立查看器      编辑器
  (Viewer)     (Editor)
  │              │
  └── 查看模式   └── 查看模式
      (只读)        (临时只读)
```

## 6. 用户选择指南

### 6.1 使用独立查看器的情况

**推荐使用独立查看器，如果你：**

✓ 只需要查看卡片，不需要编辑  
✓ 希望软件启动快速、占用资源少  
✓ 在移动设备上使用  
✓ 设备存储空间有限  
✓ 需要将查看器作为默认打开程序  
✓ 需要分享查看器给他人使用  
✓ 在低配设备上使用

### 6.2 使用编辑器查看模式的情况

**推荐使用编辑器的查看模式，如果你：**

✓ 需要频繁在查看和编辑之间切换  
✓ 正在创作内容，需要预览效果  
✓ 已经打开了编辑器，不想启动额外应用  
✓ 需要在查看时快速做笔记或修改  
✓ 想要在同一个窗口中工作  
✓ 设备性能足够，不在意体积和启动速度

### 6.3 两者结合使用

很多用户会同时安装两者：

- **日常浏览**：双击卡片用查看器打开，快速查看
- **深度工作**：在编辑器中创作，使用查看模式预览
- **分享传播**：将轻量级查看器分享给他人
- **移动+桌面**：移动端用查看器，桌面端用编辑器

## 7. 开发和维护

### 7.1 代码组织

```
chips-core/              # 薯片内核（共享）
├── parser/              # 文件解析
├── renderer/            # 渲染引擎
├── plugin-system/       # 插件系统
└── theme-system/        # 主题系统

chips-viewer/            # 独立查看器
├── viewer-ui/           # 查看器专用 UI
├── viewer-shell/        # 应用外壳
└── viewer-main/         # 启动入口

chips-editor/            # 编辑器
├── editor-core/         # 编辑核心
├── editor-ui/           # 编辑器 UI
├── view-mode/           # 查看模式（复用 chips-core）
└── editor-main/         # 启动入口
```

### 7.2 开发策略

1. **核心先行**
   - 先开发薯片内核的查看能力
   - 确保渲染和插件系统稳定
   - 核心功能在两者中完全一致

2. **并行开发**
   - 独立查看器和编辑器查看模式并行开发
   - 共享核心代码，独立开发 UI
   - 确保两者的功能对等

3. **测试保障**
   - 编写共享的渲染测试用例
   - 确保两者显示效果一致
   - 性能基准测试

### 7.3 版本同步

- **内核版本**：独立管理，两者依赖相同版本
- **查看器版本**：独立发版，版本号独立
- **编辑器版本**：独立发版，版本号独立
- **兼容性保证**：同一时期的版本互相兼容

## 8. 功能对比

### 8.1 功能对比表

| 功能 | 独立查看器 | 编辑器查看模式 |
|------|------------|----------------|
| **基础查看** |
| 卡片渲染 | ✓ | ✓ |
| 箱子展示 | ✓ | ✓ |
| 主题应用 | ✓ | ✓ |
| 多媒体播放 | ✓ | ✓ |
| 查看工具插件 | ✓ | ✓ |
| **性能** |
| 启动速度 | 快（< 2s） | 慢（< 5s） |
| 内存占用 | 低（< 200MB） | 高（< 500MB） |
| 安装体积 | 小（50-100MB） | 大（200-500MB） |
| **交互** |
| 导航浏览 | ✓ | ✓ |
| 搜索筛选 | ✓ | ✓ |
| 全屏模式 | ✓ | ✓ |
| 键盘快捷键 | ✓ | ✓ |
| **编辑功能** |
| 内容编辑 | ✗ | ✓（切换模式） |
| 卡片创建 | ✗ | ✓（切换模式） |
| 快速修改 | ✗ | ✓（切换模式） |
| **平台** |
| Windows | ✓ | ✓ |
| macOS | ✓ | ✓ |
| Linux | ✓ | ✓ |
| iOS | ✓ | ✗ |
| Android | ✓ | ✗ |
| Web | ✓ | ✓ |
| **使用场景** |
| 快速查看 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 移动端 | ⭐⭐⭐⭐⭐ | ⭐ |
| 内容创作预览 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 编辑后审阅 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 内容分享 | ⭐⭐⭐⭐⭐ | ⭐ |

### 8.2 性能对比

| 指标 | 独立查看器 | 编辑器查看模式 |
|------|------------|----------------|
| 冷启动时间 | < 2 秒 | < 5 秒 |
| 热启动时间 | < 1 秒 | < 2 秒 |
| 卡片打开时间 | < 500ms | < 500ms |
| 内存占用（空闲） | < 200MB | < 500MB |
| 内存占用（查看） | < 500MB | < 800MB |
| CPU 占用（空闲） | < 5% | < 10% |
| 安装包体积 | 50-100MB | 200-500MB |

## 9. 技术实现

### 9.1 模式切换实现

编辑器的查看模式切换通过以下机制实现：

```javascript
// 伪代码示例
class Editor {
  constructor() {
    this.mode = 'edit'; // 或 'view'
    this.viewModeController = new ViewModeController();
  }
  
  switchToViewMode() {
    // 保存当前编辑状态
    this.saveEditState();
    
    // 禁用编辑功能
    this.disableEditFeatures();
    
    // 切换 UI
    this.ui.switchToViewMode();
    
    // 加载查看模式控制器
    this.viewModeController.activate();
    
    // 更新状态
    this.mode = 'view';
  }
  
  switchToEditMode() {
    // 停用查看模式控制器
    this.viewModeController.deactivate();
    
    // 恢复 UI
    this.ui.switchToEditMode();
    
    // 启用编辑功能
    this.enableEditFeatures();
    
    // 恢复编辑状态
    this.restoreEditState();
    
    // 更新状态
    this.mode = 'edit';
  }
}
```

### 9.2 共享渲染引擎

```javascript
// chips-core/renderer/index.js
export class CardRenderer {
  render(card, options) {
    // 统一的渲染逻辑
    // 被独立查看器和编辑器共同使用
  }
}

// chips-viewer/main.js
import { CardRenderer } from 'chips-core';
const renderer = new CardRenderer();

// chips-editor/view-mode.js
import { CardRenderer } from 'chips-core';
const renderer = new CardRenderer();
```

### 9.3 打包策略

```
独立查看器打包:
chips-viewer.exe
├── chips-core (内嵌)
├── viewer-ui
└── 运行时依赖

编辑器打包:
chips-editor.exe
├── chips-core (内嵌)
├── editor-core
├── editor-ui
├── view-mode (使用 chips-core)
└── 运行时依赖
```

## 10. 未来演进

### 10.1 短期计划

1. **功能对等**
   - 确保两者的查看功能完全一致
   - 同步更新查看相关的功能
   - 统一用户体验

2. **性能优化**
   - 优化独立查看器的启动速度
   - 优化编辑器查看模式的切换速度
   - 减少内存占用

### 10.2 长期愿景

1. **更多形态**
   - 浏览器插件版查看器
   - 系统快速预览插件（Quick Look、File Explorer）
   - 命令行查看工具

2. **智能适配**
   - 根据设备性能自动选择版本
   - 根据使用场景推荐合适的工具
   - 云端查看服务

3. **深度集成**
   - 与操作系统更深度集成
   - 与其他 Chips 工具无缝协作
   - 打造完整的内容生态

## 11. 总结

Chips Viewer 和 Chips Editor 的关系体现了"专业化分工"与"功能集成"的平衡：

- **独立查看器**：轻量、快速、专注，适合纯查看场景
- **编辑器查看模式**：完整、便捷、集成，适合创作场景
- **共享核心**：确保一致性和可维护性
- **用户选择**：根据需求和场景灵活选择

这种双轨设计让 Chips 能够服务更广泛的用户群体，同时保持技术架构的简洁和可维护性。

# Phase 3: 插件系统与渲染集成

**阶段目标**：实现插件系统，完成与 Foundation 层渲染服务的集成  
**预计工期**：6天  
**开发模式**：顺序开发（插件系统是核心功能）

---

## 任务清单

### 任务 3.1：PluginManager 插件管理器（1.5天）

#### 3.1.1 PluginManager 核心实现

**描述**：实现插件管理器，管理插件的安装、启用、禁用和卸载

**文件**：`src/renderer/core/plugin/PluginManager.ts`

**类设计**：

```typescript
/**
 * PluginManager - 插件管理器
 * 
 * 职责：
 * 1. 管理插件生命周期
 * 2. 维护插件注册表
 * 3. 提供插件查询接口
 * 4. 管理插件配置
 */
export class PluginManager implements IPluginManager {
  private plugins: Map<string, PluginInstance> = new Map();
  private contexts: Map<string, PluginContext> = new Map();
  private renderers: Map<string, RendererDefinition> = new Map();
  private commands: Map<string, CommandHandler> = new Map();
  private logger: ILogger;
  private eventBus: IEventBus;
  
  constructor(eventBus: IEventBus);
  
  /**
   * 注册插件
   */
  register(registration: PluginRegistration): void;
  
  /**
   * 注销插件
   */
  async unregister(id: string): Promise<void>;
  
  /**
   * 启用插件
   */
  async enable(id: string): Promise<void>;
  
  /**
   * 禁用插件
   */
  async disable(id: string): Promise<void>;
  
  /**
   * 获取插件实例
   */
  get(id: string): PluginInstance | undefined;
  
  /**
   * 获取插件元数据
   */
  getMetadata(id: string): PluginMetadata | undefined;
  
  /**
   * 获取插件状态
   */
  getState(id: string): PluginState | undefined;
  
  /**
   * 检查插件是否启用
   */
  isEnabled(id: string): boolean;
  
  /**
   * 列出所有插件
   */
  list(options?: PluginQueryOptions): PluginInstance[];
  
  /**
   * 更新插件配置
   */
  updateConfig(id: string, config: Partial<Record<string, unknown>>): void;
  
  /**
   * 执行插件命令
   */
  async executeCommand(name: string, args?: unknown): Promise<unknown>;
  
  /**
   * 获取支持指定类型的渲染器
   */
  getRenderer(cardType: string): RendererDefinition | undefined;
  
  /**
   * 获取文件对应的插件
   */
  getPluginForFile(path: string): PluginInstance | undefined;
  
  /**
   * 获取支持指定 MIME 类型的插件列表
   */
  getPluginsForType(mimeType: string): PluginInstance[];
  
  /**
   * 获取所有已注册的命令
   */
  getCommands(): string[];
  
  /**
   * 获取所有已注册的渲染器类型
   */
  getRendererTypes(): string[];
  
  /**
   * 获取插件数量
   */
  get count(): number;
  
  /**
   * 获取已启用插件数量
   */
  get enabledCount(): number;
  
  // 私有方法
  private createContext(id: string): PluginContext;
  private validatePlugin(registration: PluginRegistration): void;
  private activatePlugin(id: string): Promise<void>;
  private deactivatePlugin(id: string): Promise<void>;
  private persistPluginState(): void;
  private loadPluginState(): void;
}
```

**实现要点**：
1. 使用 Map 存储插件实例
2. 为每个插件创建独立的上下文
3. 支持插件状态持久化
4. 实现插件生命周期管理

**验收标准**：
- [ ] PluginManager 类实现完整
- [ ] 插件注册和注销正常
- [ ] 启用/禁用功能正常
- [ ] 查询接口完整
- [ ] 单元测试覆盖率 ≥ 90%

---

#### 3.1.2 PluginContext 实现

**描述**：实现插件上下文，提供插件运行时所需的 API

**文件**：`src/renderer/core/plugin/PluginContext.ts`

```typescript
/**
 * PluginContext - 插件上下文
 * 
 * 为插件提供安全的、受限的 API 访问
 */
export class PluginContextImpl implements PluginContext {
  pluginId: string;
  sdkVersion: string;
  config: Record<string, unknown>;
  
  private eventBus: IEventBus;
  private commandRegistry: Map<string, CommandHandler>;
  private rendererRegistry: Map<string, RendererDefinition>;
  private eventHandlers: Map<string, Set<(data: unknown) => void>> = new Map();
  private logger: ILogger;
  
  constructor(
    pluginId: string,
    eventBus: IEventBus,
    commandRegistry: Map<string, CommandHandler>,
    rendererRegistry: Map<string, RendererDefinition>,
    config?: Record<string, unknown>
  );
  
  // API 访问
  api = {
    file: {
      read: async (path: string): Promise<ArrayBuffer> => { /* ... */ },
      readText: async (path: string): Promise<string> => { /* ... */ },
      exists: async (path: string): Promise<boolean> => { /* ... */ },
    },
    storage: {
      get: <T>(key: string, defaultValue?: T): T => { /* ... */ },
      set: (key: string, value: unknown): void => { /* ... */ },
      remove: (key: string): void => { /* ... */ },
    },
    theme: {
      getCurrent: (): string => { /* ... */ },
      getVariable: (name: string): string => { /* ... */ },
    },
    i18n: {
      t: (key: string, params?: Record<string, unknown>): string => { /* ... */ },
      getLocale: (): string => { /* ... */ },
    },
  };
  
  /**
   * 日志方法
   */
  log(message: string, data?: unknown): void;
  
  /**
   * 注册命令
   */
  registerCommand(name: string, handler: CommandHandler): void;
  
  /**
   * 注册渲染器
   */
  registerRenderer(type: string, renderer: RendererDefinition): void;
  
  /**
   * 发布事件
   */
  emit(event: string, data: unknown): void;
  
  /**
   * 订阅事件
   */
  on(event: string, handler: (data: unknown) => void): void;
  
  /**
   * 取消订阅
   */
  off(event: string, handler?: (data: unknown) => void): void;
  
  /**
   * 获取设置
   */
  getSettings(): Record<string, unknown>;
  
  /**
   * 更新设置
   */
  updateSettings(settings: Partial<Record<string, unknown>>): void;
  
  /**
   * 销毁上下文
   */
  destroy(): void;
}
```

**验收标准**：
- [ ] PluginContext 类实现完整
- [ ] API 访问安全受限
- [ ] 事件系统正常
- [ ] 设置管理正常

---

### 任务 3.2：PluginLoader 插件加载器（1天）

#### 3.2.1 PluginLoader 实现

**描述**：实现插件加载器，负责从文件系统或网络加载插件

**文件**：`src/renderer/core/plugin/PluginLoader.ts`

```typescript
/**
 * PluginLoader - 插件加载器
 * 
 * 职责：
 * 1. 从文件系统加载插件
 * 2. 解析插件清单
 * 3. 验证插件完整性
 * 4. 加载内置插件
 */
export class PluginLoader {
  private logger: ILogger;
  private builtinPlugins: PluginRegistration[] = [];
  
  constructor();
  
  /**
   * 加载内置插件
   */
  async loadBuiltinPlugins(): Promise<PluginRegistration[]>;
  
  /**
   * 从路径加载插件
   */
  async loadFromPath(pluginPath: string): Promise<PluginRegistration>;
  
  /**
   * 从清单加载插件
   */
  async loadFromManifest(manifest: PluginManifest, basePath: string): Promise<PluginRegistration>;
  
  /**
   * 扫描目录下的所有插件
   */
  async scanDirectory(directory: string): Promise<PluginRegistration[]>;
  
  /**
   * 验证插件清单
   */
  validateManifest(manifest: PluginManifest): { valid: boolean; errors: string[] };
  
  /**
   * 检查插件兼容性
   */
  checkCompatibility(manifest: PluginManifest): { compatible: boolean; reason?: string };
  
  /**
   * 注册内置插件
   */
  registerBuiltinPlugin(registration: PluginRegistration): void;
  
  // 私有方法
  private parseManifest(content: string): PluginManifest;
  private loadPluginModule(mainPath: string): Promise<unknown>;
  private resolvePluginPath(basePath: string, relativePath: string): string;
}
```

**内置插件列表**：
1. 视频查看器 (video-viewer)
2. 图片查看器 (image-viewer)
3. 代码查看器 (code-viewer)
4. PDF 查看器 (pdf-viewer)
5. Markdown 查看器 (markdown-viewer)
6. 富文本查看器 (richtext-viewer)

**验收标准**：
- [ ] PluginLoader 类实现完整
- [ ] 内置插件加载正常
- [ ] 外部插件加载正常
- [ ] 清单验证正确
- [ ] 单元测试覆盖率 ≥ 90%

---

### 任务 3.3：PluginDispatcher 插件调度器（1天）

#### 3.3.1 PluginDispatcher 实现

**描述**：实现插件调度器，根据文件类型选择合适的插件

**文件**：`src/renderer/core/plugin/PluginDispatcher.ts`

```typescript
/**
 * PluginDispatcher - 插件调度器
 * 
 * 职责：
 * 1. 根据文件类型选择插件
 * 2. 管理默认插件设置
 * 3. 实现插件优先级排序
 * 4. 提供回退机制
 */
export class PluginDispatcher {
  private pluginManager: IPluginManager;
  private defaultPlugins: Map<string, string> = new Map();
  private logger: ILogger;
  
  constructor(pluginManager: IPluginManager);
  
  /**
   * 为文件选择最佳插件
   */
  async dispatch(file: FileInfo): Promise<PluginInstance | null>;
  
  /**
   * 获取文件支持的所有插件
   */
  getAvailablePlugins(file: FileInfo): PluginInstance[];
  
  /**
   * 设置文件类型的默认插件
   */
  setDefaultPlugin(mimeType: string, pluginId: string): void;
  
  /**
   * 获取文件类型的默认插件
   */
  getDefaultPlugin(mimeType: string): string | null;
  
  /**
   * 清除默认插件设置
   */
  clearDefaultPlugin(mimeType: string): void;
  
  /**
   * 获取所有默认插件设置
   */
  getDefaultPluginSettings(): Map<string, string>;
  
  /**
   * 获取回退插件
   */
  getFallbackPlugin(): PluginInstance | null;
  
  // 私有方法
  private sortByPriority(plugins: PluginInstance[], file: FileInfo): PluginInstance[];
  private calculatePluginScore(plugin: PluginInstance, file: FileInfo): number;
  private checkPluginSupport(plugin: PluginInstance, file: FileInfo): boolean;
  private persistDefaultSettings(): void;
  private loadDefaultSettings(): void;
}
```

**调度策略**：
1. 检查用户设置的默认插件
2. 检查文件扩展名匹配
3. 检查 MIME 类型匹配
4. 按优先级排序候选插件
5. 返回最佳匹配或回退插件

**验收标准**：
- [ ] PluginDispatcher 类实现完整
- [ ] 调度策略正确
- [ ] 默认插件设置生效
- [ ] 回退机制正常
- [ ] 单元测试覆盖率 ≥ 90%

---

### 任务 3.4：PluginSandbox 插件沙箱（1天）

#### 3.4.1 PluginSandbox 实现

**描述**：实现插件沙箱，提供安全隔离的插件执行环境

**文件**：`src/renderer/core/plugin/PluginSandbox.ts`

```typescript
/**
 * PluginSandbox - 插件沙箱
 * 
 * 职责：
 * 1. 创建隔离的执行环境
 * 2. 限制插件访问权限
 * 3. 监控插件行为
 * 4. 处理插件异常
 */
export class PluginSandbox {
  private logger: ILogger;
  private sandboxes: Map<string, HTMLIFrameElement> = new Map();
  
  constructor();
  
  /**
   * 在沙箱中加载插件
   */
  async loadInSandbox(
    pluginId: string, 
    code: string, 
    manifest: PluginManifest
  ): Promise<unknown>;
  
  /**
   * 创建受限上下文
   */
  createRestrictedContext(manifest: PluginManifest): Record<string, unknown>;
  
  /**
   * 在沙箱中执行代码
   */
  async executeInSandbox(
    pluginId: string, 
    code: string, 
    context: Record<string, unknown>
  ): Promise<unknown>;
  
  /**
   * 销毁插件沙箱
   */
  destroySandbox(pluginId: string): void;
  
  /**
   * 销毁所有沙箱
   */
  destroyAll(): void;
  
  /**
   * 检查权限
   */
  hasPermission(manifest: PluginManifest, permission: string): boolean;
  
  /**
   * 获取沙箱状态
   */
  getSandboxStatus(pluginId: string): 'active' | 'inactive' | 'error' | null;
  
  // 私有方法
  private createSandboxIframe(pluginId: string): HTMLIFrameElement;
  private injectContext(iframe: HTMLIFrameElement, context: Record<string, unknown>): void;
  private setupMessageHandler(iframe: HTMLIFrameElement, pluginId: string): void;
  private wrapAPIWithPermissionCheck(api: unknown, permissions: string[]): unknown;
}
```

**安全措施**：
1. 使用 iframe sandbox 属性
2. 禁用危险的全局对象（eval, Function 等）
3. 代理所有 API 调用，检查权限
4. 超时保护
5. 资源使用限制

**验收标准**：
- [ ] PluginSandbox 类实现完整
- [ ] 沙箱隔离有效
- [ ] 权限检查正确
- [ ] 异常处理完善
- [ ] 单元测试覆盖率 ≥ 90%

---

### 任务 3.5：渲染引擎集成（1天）

#### 3.5.1 RenderingBridge 实现

**描述**：实现渲染桥接层，连接 Viewer 和 Foundation 的渲染服务

**文件**：`src/renderer/core/rendering/RenderingBridge.ts`

```typescript
/**
 * RenderingBridge - 渲染桥接层
 * 
 * 职责：
 * 1. 封装 Foundation 渲染服务调用
 * 2. 管理渲染缓存
 * 3. 处理渲染结果
 * 4. 提供渲染工具函数
 */
export class RenderingBridge {
  private sdkService: SDKService;
  private cache: Map<string, RenderCacheEntry> = new Map();
  private logger: ILogger;
  private maxCacheSize: number;
  
  constructor(sdkService: SDKService, options?: RenderingBridgeOptions);
  
  /**
   * 渲染卡片
   */
  async renderCard(
    card: Card, 
    container: HTMLElement, 
    options: CardRenderOptions
  ): Promise<CardRenderResult>;
  
  /**
   * 渲染箱子
   */
  async renderBox(
    box: Box, 
    container: HTMLElement, 
    options: BoxRenderOptions
  ): Promise<BoxRenderResult>;
  
  /**
   * 渲染卡片封面
   */
  async renderCover(card: Card, container: HTMLElement): Promise<RenderResult>;
  
  /**
   * 渲染预览
   */
  async renderPreview(
    data: Card | Box, 
    container: HTMLElement, 
    options?: PreviewOptions
  ): Promise<RenderResult>;
  
  /**
   * 清除缓存
   */
  clearCache(): void;
  
  /**
   * 获取缓存统计
   */
  getCacheStats(): { size: number; hitRate: number };
  
  /**
   * 预加载内容
   */
  async preload(paths: string[]): Promise<void>;
  
  // 私有方法
  private getCacheKey(data: Card | Box, options: unknown): string;
  private isCacheValid(entry: RenderCacheEntry): boolean;
  private cleanupOldCache(): void;
  private processRenderResult(result: unknown): RenderResult;
}

interface RenderCacheEntry {
  result: RenderResult;
  timestamp: number;
  accessCount: number;
}

interface RenderingBridgeOptions {
  maxCacheSize?: number;
  cacheTTL?: number;
  preloadEnabled?: boolean;
}

interface PreviewOptions {
  width?: number;
  height?: number;
  quality?: 'low' | 'medium' | 'high';
}
```

**验收标准**：
- [ ] RenderingBridge 类实现完整
- [ ] 卡片渲染正常
- [ ] 箱子渲染正常
- [ ] 缓存机制有效
- [ ] 单元测试覆盖率 ≥ 90%

---

#### 3.5.2 IFrameManager 实现

**描述**：实现 iframe 管理器，管理渲染产生的 iframe 元素

**文件**：`src/renderer/core/rendering/IFrameManager.ts`

```typescript
/**
 * IFrameManager - iframe 管理器
 * 
 * 职责：
 * 1. 管理活跃的 iframe 元素
 * 2. 建立与 iframe 的通信通道
 * 3. 处理 iframe 消息
 * 4. 清理销毁 iframe
 */
export class IFrameManager {
  private frames: Map<string, ManagedFrame> = new Map();
  private messageHandlers: Map<string, Set<MessageHandler>> = new Map();
  private logger: ILogger;
  
  constructor();
  
  /**
   * 注册 iframe
   */
  register(id: string, frame: HTMLIFrameElement, options?: FrameOptions): void;
  
  /**
   * 注销 iframe
   */
  unregister(id: string): void;
  
  /**
   * 获取 iframe
   */
  get(id: string): HTMLIFrameElement | null;
  
  /**
   * 向 iframe 发送消息
   */
  postMessage(id: string, message: unknown): void;
  
  /**
   * 广播消息到所有 iframe
   */
  broadcast(message: unknown): void;
  
  /**
   * 添加消息处理器
   */
  onMessage(id: string, handler: MessageHandler): void;
  
  /**
   * 移除消息处理器
   */
  offMessage(id: string, handler?: MessageHandler): void;
  
  /**
   * 调整 iframe 大小
   */
  resize(id: string, width?: number, height?: number): void;
  
  /**
   * 设置 iframe 缩放
   */
  setZoom(id: string, zoom: number): void;
  
  /**
   * 滚动 iframe 到指定位置
   */
  scrollTo(id: string, x: number, y: number): void;
  
  /**
   * 销毁所有 iframe
   */
  destroyAll(): void;
  
  /**
   * 获取 iframe 数量
   */
  get count(): number;
  
  // 私有方法
  private setupMessageListener(): void;
  private handleMessage(event: MessageEvent): void;
  private createCommunicationChannel(frame: HTMLIFrameElement): void;
}

interface ManagedFrame {
  frame: HTMLIFrameElement;
  options: FrameOptions;
  createdAt: Date;
}

interface FrameOptions {
  allowResize?: boolean;
  allowScroll?: boolean;
  sandbox?: string[];
}

type MessageHandler = (message: unknown) => void;
```

**验收标准**：
- [ ] IFrameManager 类实现完整
- [ ] iframe 注册和注销正常
- [ ] 消息通信正常
- [ ] 资源清理完整
- [ ] 单元测试覆盖率 ≥ 90%

---

### 任务 3.6：内置插件实现（0.5天）

#### 3.6.1 内置插件框架

**描述**：创建内置插件的基础框架和示例实现

**文件**：`src/plugins/builtin.ts`

```typescript
/**
 * 内置插件注册
 */
import type { PluginRegistration } from '@common/types';

// 视频查看器插件
export const videoViewerPlugin: PluginRegistration = {
  id: 'chips:video-viewer',
  metadata: {
    id: 'chips:video-viewer',
    name: '视频查看器',
    version: '1.0.0',
    type: 'viewer-tool',
    description: '内置视频播放插件',
    supportedTypes: ['video/mp4', 'video/webm', 'video/ogg'],
    supportedExtensions: ['.mp4', '.webm', '.ogg', '.mov'],
  },
  activate: async (ctx) => {
    ctx.log('Video viewer plugin activated');
    
    ctx.registerRenderer('video', {
      cardTypes: ['VideoCard'],
      render: async (context) => {
        // 通过内核路由调用 Foundation 的 VideoPlayer
        return { success: true, html: '' };
      },
    });
  },
  deactivate: async () => {
    // 清理资源
  },
};

// 图片查看器插件
export const imageViewerPlugin: PluginRegistration = {
  id: 'chips:image-viewer',
  metadata: {
    id: 'chips:image-viewer',
    name: '图片查看器',
    version: '1.0.0',
    type: 'viewer-tool',
    description: '内置图片查看插件',
    supportedTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    supportedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
  },
  activate: async (ctx) => {
    ctx.log('Image viewer plugin activated');
    
    ctx.registerRenderer('image', {
      cardTypes: ['ImageCard'],
      render: async (context) => {
        return { success: true, html: '' };
      },
    });
  },
};

// 导出所有内置插件
export const builtinPlugins: PluginRegistration[] = [
  videoViewerPlugin,
  imageViewerPlugin,
  // ... 其他内置插件
];
```

**验收标准**：
- [ ] 内置插件框架创建完成
- [ ] 至少实现 2 个内置插件
- [ ] 插件可正常加载和使用

---

## 阶段完成标准

### 必须完成项

- [ ] PluginManager 实现完成
- [ ] PluginLoader 实现完成
- [ ] PluginDispatcher 实现完成
- [ ] PluginSandbox 实现完成
- [ ] RenderingBridge 实现完成
- [ ] IFrameManager 实现完成
- [ ] 内置插件框架完成
- [ ] 插件可以正常加载和使用
- [ ] 卡片渲染流程完整

### 质量要求

- [ ] 单元测试覆盖率 ≥ 80%
- [ ] 集成测试通过
- [ ] 插件隔离安全
- [ ] TypeScript 类型检查通过
- [ ] 代码注释完整

### 提交记录

完成后应有以下 Git 提交：
1. `feat: 实现 PluginManager 插件管理器`
2. `feat: 实现 PluginContext 插件上下文`
3. `feat: 实现 PluginLoader 插件加载器`
4. `feat: 实现 PluginDispatcher 插件调度器`
5. `feat: 实现 PluginSandbox 插件沙箱`
6. `feat: 实现 RenderingBridge 渲染桥接层`
7. `feat: 实现 IFrameManager`
8. `feat: 添加内置插件`

---

**下一阶段**：Phase 4 - UI 组件与交互

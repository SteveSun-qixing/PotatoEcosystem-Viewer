# 查看器开发规范

**版本**: 1.0.0  
**最后更新**: 2026-01-30  
**适用范围**: chips-viewer 卡片查看器

---

## 📌 技术栈说明

**前端框架**: Vue 3 + TypeScript  
**桌面端**: Electron  
**状态管理**: Pinia  
**组件库**: @chips/components（无样式组件）  
**媒体播放**: Video.js、Howler.js

**重要文档**:
- [项目技术栈标准](../生态共用/架构设计/11-项目技术栈标准.md)
- [查看器架构设计](../生态共用/架构设计/08-产品架构设计.md)

---

## 1. 架构规范

### 1.1 中心路由原则 ⭐ 最重要

**强制要求**:
- ✅ 所有模块间通信**必须**通过薯片内核路由
- ❌ **禁止**模块之间直接调用或通信
- ✅ 所有外部输入**必须**经过内核统一入口

**实现要求**:
```rust
// ✅ 正确：通过内核路由
kernel.request("target_module", "method", params).await?;

// ❌ 错误：直接调用
target_module.method(params); // 禁止！
```

**违规检查**:
- 代码审查必须检查是否有直接模块调用
- CI/CD中集成静态分析工具检测跨模块引用

### 1.2 模块化设计

**要求**:
- 每个功能模块必须独立可替换
- 模块只通过标准接口对外暴露
- 模块内部实现对外部完全透明

**模块注册**:
```rust
// 模块必须通过内核注册
kernel.register_module(ModuleDescriptor {
    id: "my-module",
    version: "1.0.0",
    interfaces: vec![/* 接口列表 */],
    dependencies: vec![/* 依赖列表 */],
});
```

### 1.3 前后端分离

**强制要求**:
- ✅ 前端只负责UI展示和交互
- ✅ 后端只负责业务逻辑和数据处理
- ❌ 前端**禁止**包含业务逻辑代码
- ❌ 后端**禁止**包含UI代码

**通信方式**:
- 前后端通过内核路由通信
- 使用标准化的请求/响应格式
- 遵循前端接口标准和后端接口标准

---

## 2. 多语言规范 ⭐ 核心规范

### 2.1 零硬编码原则

**绝对禁止**:
```typescript
// ❌ 禁止：硬编码文本
<button>确定</button>
alert("保存成功");
console.log("加载完成");

// ❌ 禁止：硬编码消息
throw new Error("文件未找到");
```

**正确做法**:
```typescript
// ✅ 正确：使用多语言系统
<button>{t('i18n.core.000001')}</button>
alert(t('i18n.ui.100050'));
console.log(t('i18n.log.001'));

// ✅ 正确：错误消息也使用编码
throw new Error(t('i18n.error.010001'));
```

### 2.2 开发阶段使用

**开发时使用key**:
```typescript
// 开发阶段使用可读的key
<button>{t('common.ok')}</button>
<p>{t('ui.loading')}</p>
```

**打包时自动替换**:
```bash
# 构建工具自动替换
npm run build
# common.ok → i18n.core.000001
# ui.loading → i18n.ui.100001
```

### 2.3 配置表管理

**所有文本必须在配置表中**:
```yaml
# i18n.yaml
vocabulary:
  common:
    ok: "i18n.core.000001"
    cancel: "i18n.core.000002"
    
  messages:
    save_success: "i18n.core.011001"
    file_not_found: "i18n.core.010001"
```

**强制检查**:
- CI/CD中检查是否有硬编码字符串
- 代码审查必须验证所有文本都使用t()函数

---

## 3. 代码规范

### 3.1 命名规范

**通用规范**:
- 类名：PascalCase（大驼峰）
- 函数/方法：camelCase（小驼峰）
- 常量：UPPER_SNAKE_CASE
- 变量：camelCase
- 文件名：kebab-case（短横线）

**示例**:
```typescript
// ✅ 正确
class UserManager { }
function getUserInfo() { }
const MAX_RETRY_COUNT = 3;
let userName = "张三";
// 文件名: user-manager.ts

// ❌ 错误
class user_manager { }
function GetUserInfo() { }
const maxRetryCount = 3;
let UserName = "张三";
```

### 3.2 注释规范

**必须注释的内容**:
- 所有公共API的文档注释
- 复杂算法的实现说明
- 非显而易见的代码逻辑
- TODO/FIXME标记

**注释格式**:
```typescript
/**
 * 获取用户信息
 * @param userId 用户ID（10位62进制）
 * @returns 用户信息对象
 * @throws {UserNotFoundError} 用户不存在时抛出
 */
async function getUserInfo(userId: string): Promise<User> {
  // 实现代码
}
```

**注释多语言**:
- 文档注释使用中文
- 代码内联注释使用中文
- API文档同时提供中英文

### 3.3 错误处理

**统一错误码**:
```typescript
// 使用标准错误码
enum ErrorCode {
  FILE_NOT_FOUND = 'E_FILE_001',
  NETWORK_ERROR = 'E_NET_001',
  PERMISSION_DENIED = 'E_PERM_001',
}

// 抛出错误时使用错误码
throw new ChipsError(
  ErrorCode.FILE_NOT_FOUND,
  t('i18n.error.010001')
);
```

**错误处理要求**:
- 所有异步操作必须处理错误
- 不允许空catch块
- 关键操作必须记录日志

```typescript
// ✅ 正确
try {
  await doSomething();
} catch (error) {
  logger.error('操作失败', { error, context });
  throw new ChipsError(ErrorCode.OPERATION_FAILED, error);
}

// ❌ 错误
try {
  await doSomething();
} catch (error) {
  // 空catch - 禁止！
}
```

---

## 4. 接口规范

### 4.1 API设计

**RESTful API规范**:
```
GET    /api/cards          # 获取列表
POST   /api/cards          # 创建
GET    /api/cards/:id      # 获取单个
PUT    /api/cards/:id      # 更新
DELETE /api/cards/:id      # 删除
```

**响应格式**:
```typescript
// 成功响应
{
  "code": 0,
  "message": "success",
  "data": { /* 实际数据 */ }
}

// 错误响应
{
  "code": "E_FILE_001",
  "message": "文件未找到",
  "details": { /* 错误详情 */ }
}
```

### 4.2 接口版本管理

**版本标注**:
```typescript
/**
 * @since 1.0.0
 * @deprecated 2.0.0 使用 newMethod 替代
 */
function oldMethod() { }
```

**废弃处理**:
- 标记为废弃但保留至少一个大版本
- 提供迁移指南
- 在日志中警告使用废弃API

---

## 5. 测试规范

### 5.1 测试覆盖率

**强制要求**:
- 核心模块：≥90%
- 业务模块：≥80%
- UI组件：≥70%
- 工具函数：≥95%

**测试类型**:
- 单元测试：必须覆盖所有公共函数
- 集成测试：覆盖核心业务流程
- E2E测试：覆盖关键用户路径

### 5.2 测试命名

**格式**: `describe_what_when_then`

```typescript
describe('UserManager', () => {
  describe('getUserInfo', () => {
    it('should return user when user exists', async () => {
      // 测试代码
    });
    
    it('should throw error when user not found', async () => {
      // 测试代码
    });
  });
});
```

### 5.3 Mock和Stub

**原则**:
- 外部依赖必须Mock
- 内核调用必须Mock
- 时间依赖必须可控

```typescript
// ✅ 正确：Mock内核调用
jest.mock('@chips/kernel');
mockKernel.request.mockResolvedValue(mockData);
```

---

## 6. 性能规范

### 6.1 性能指标

**强制要求**:
- 内核路由延迟：<10ms (P95)
- 模块加载时间：<100ms
- UI响应时间：<100ms
- API响应时间：<200ms (P95)

### 6.2 优化要求

**必须实现**:
- 按需加载：模块和资源懒加载
- 缓存策略：合理使用内存和磁盘缓存
- 防抖节流：高频操作必须防抖
- 虚拟滚动：长列表必须虚拟化

**示例**:
```typescript
// ✅ 防抖
const debouncedSave = debounce(save, 500);

// ✅ 虚拟滚动
<VirtualList items={items} itemHeight={50} />

// ✅ 懒加载
const Module = lazy(() => import('./Module'));
```

---

## 7. 安全规范

### 7.1 输入验证

**强制要求**:
- 所有用户输入必须验证
- 所有外部数据必须清洗
- 使用白名单而非黑名单

```typescript
// ✅ 正确：验证输入
function setUserName(name: string) {
  if (!isValidUserName(name)) {
    throw new ValidationError('无效的用户名');
  }
  // 处理
}
```

### 7.2 XSS防护

**要求**:
- 所有用户输入的HTML必须转义
- 使用安全的DOM操作方法
- CSP策略配置

```typescript
// ✅ 正确：转义HTML
const safeHtml = escapeHtml(userInput);

// ❌ 错误：直接插入
element.innerHTML = userInput; // 禁止！
```

### 7.3 认证和权限

**要求**:
- API调用必须验证权限
- 敏感操作必须二次确认
- 密钥和令牌不得硬编码

---

## 8. 日志规范

### 8.1 日志级别

**使用标准**:
- ERROR：错误和异常
- WARN：警告信息
- INFO：重要事件
- DEBUG：调试信息（生产关闭）

### 8.2 日志格式

**标准格式**:
```typescript
logger.info('用户登录成功', {
  userId: user.id,
  ip: request.ip,
  timestamp: Date.now(),
});
```

**不允许**:
```typescript
// ❌ 不使用console.log
console.log('用户登录'); // 禁止！

// ✅ 使用日志系统
logger.info('用户登录成功', { userId });
```

---

## 9. Git规范

### 9.1 分支管理

**分支类型**:
- `main`: 主分支，生产代码
- `develop`: 开发分支
- `feature/*`: 功能分支
- `fix/*`: 修复分支
- `release/*`: 发布分支

### 9.2 提交规范

**Commit格式**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type类型**:
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码格式
- refactor: 重构
- test: 测试相关
- chore: 构建/工具

**示例**:
```
feat(editor): 添加无限画布缩放功能

- 实现缩放手势支持
- 添加缩放比例显示
- 优化缩放性能

Closes #123
```

---

## 10. 文档规范

### 10.1 代码文档

**必须包含**:
- README.md：项目说明
- API文档：所有公开API
- CHANGELOG.md：变更日志
- 贡献指南

### 10.2 文档更新

**要求**:
- API变更必须同步更新文档
- 新功能必须有使用说明
- 废弃功能必须有迁移指南

---

## 11. 依赖管理

### 11.1 依赖选择

**原则**:
- 优先使用生态内的依赖
- 外部依赖必须评估
- 避免重复依赖

**评估标准**:
- 维护活跃度
- 许可证兼容性
- 安全性记录
- 社区支持

### 11.2 版本锁定

**要求**:
- 使用锁文件（package-lock.json/Cargo.lock）
- 定期更新依赖
- 及时修复安全漏洞

---

## 12. CI/CD规范

### 12.1 持续集成

**必须包含**:
- 代码检查（Lint）
- 单元测试
- 集成测试
- 构建验证

**流程**:
```yaml
# .github/workflows/ci.yml
on: [push, pull_request]
jobs:
  test:
    - run: npm run lint
    - run: npm run test
    - run: npm run build
```

### 12.2 持续部署

**要求**:
- 自动化部署流程
- 灰度发布支持
- 回滚机制

---

## 13. 代码审查

### 13.1 审查要点

**必须检查**:
- [ ] 是否遵循中心路由原则
- [ ] 是否有硬编码文本
- [ ] 是否有适当的错误处理
- [ ] 是否有足够的测试覆盖
- [ ] 是否有文档更新
- [ ] 是否符合性能要求

### 13.2 审查流程

**要求**:
- 所有PR必须经过代码审查
- 至少一人approval才能合并
- 关键模块需要专家审查

---

## 14. 开源合规

### 14.1 许可证

**要求**:
- 明确标注使用的开源库
- 遵守开源许可证要求
- 贡献代码必须有CLA

### 14.2 开源组件

**使用原则**:
- 优先使用MIT/Apache 2.0许可证
- 避免使用GPL许可证（传染性）
- 记录所有开源依赖

**文档要求**:
```markdown
# 第三方依赖

- React (MIT License)
- Video.js (Apache 2.0)
- ...
```

---

## 15. 开发环境

### 15.1 环境配置

**标准化**:
- 使用.env文件管理环境变量
- 提供开发环境配置模板
- 不提交敏感配置

```bash
# .env.example
DATABASE_URL=postgres://localhost/chips
API_KEY=your_api_key_here
```

### 15.2 开发工具

**推荐工具**:
- IDE: VSCode/Cursor
- 格式化: Prettier/rustfmt
- Lint: ESLint/clippy
- Git Hook: Husky

---

## 16. 违规处理

### 16.1 严重违规

**以下行为禁止合并代码**:
- 违反中心路由原则
- 包含硬编码文本
- 没有错误处理的关键操作
- 测试覆盖率不达标

### 16.2 警告处理

**以下行为需要修改**:
- 命名不规范
- 注释缺失
- 日志不完整
- 性能问题

---

## 17. 开发流程

### 17.1 功能开发

**标准流程**:
1. 创建功能分支
2. 编写代码和测试
3. 自测通过
4. 提交PR
5. 代码审查
6. 修改问题
7. 合并到develop

### 17.2 Bug修复

**标准流程**:
1. 创建修复分支
2. 编写测试重现bug
3. 修复代码
4. 测试验证
5. 提交PR
6. 快速审查
7. 合并到main

---

## 18. 附录

### 18.1 相关文档

- [薯片协议规范](../生态共用/01-薯片协议规范.md)
- [多语言系统规范](../生态共用/11-多语言系统规范.md)
- [前端接口标准](../生态共用/05-前端接口标准.md)
- [后端接口标准](../生态共用/06-后端接口标准.md)
- [插件开发规范](../生态共用/07-插件开发规范.md)

### 18.2 检查清单

**代码提交前检查**:
- [ ] 无硬编码文本
- [ ] 遵循中心路由
- [ ] 错误处理完整
- [ ] 测试覆盖率达标
- [ ] 代码格式化
- [ ] 文档已更新
- [ ] Commit信息规范

---

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-30  
**状态**: ✅ 生效

---

## 19. 查看器特定开发规范

### 19.1 渲染引擎规范

#### 19.1.1 卡片渲染规范

**基本要求**:
- 所有卡片类型必须有对应的渲染器实现
- 渲染器必须实现 `ICardRenderer` 接口
- 渲染结果必须包含 `dispose` 方法用于清理资源

**渲染器接口**:
```typescript
interface ICardRenderer {
  render(card: Card, container: HTMLElement, options?: RenderOptions): Promise<RenderResult>;
  update(cardId: string, updates: Partial<Card>): void;
  dispose(cardId: string): void;
}
```

**命名规范**:
```typescript
// ✅ 正确：遵循命名约定
class RichTextCardRenderer implements ICardRenderer { }
class MarkdownCardRenderer implements ICardRenderer { }
class VideoCardRenderer implements ICardRenderer { }

// ❌ 错误：不符合命名规范
class RichText { }  // 缺少 CardRenderer 后缀
class renderer_markdown { }  // 使用下划线
```

**错误处理**:
```typescript
// ✅ 正确：完整的错误处理
async render(card: Card, container: HTMLElement): Promise<RenderResult> {
  try {
    // 验证参数
    if (!card || !container) {
      throw new ValidationError(t('i18n.error.020001'));
    }
    
    // 渲染逻辑
    const element = await this.doRender(card);
    container.appendChild(element);
    
    return {
      element,
      dispose: () => this.cleanup(element)
    };
  } catch (error) {
    logger.error(t('i18n.error.020002'), { card, error });
    throw new RenderError(t('i18n.error.020003'), error);
  }
}
```

#### 19.1.2 主题应用规范

**CSS变量命名**:
```css
/* ✅ 正确：使用标准前缀 */
:root {
  --color-primary: #1976d2;
  --color-surface: #f5f5f5;
  --font-family: 'Roboto';
  --spacing-md: 16px;
}

/* ❌ 错误：不规范的命名 */
:root {
  --primaryColor: #1976d2;  /* 使用驼峰 */
  --space: 16px;  /* 不明确 */
}
```

**主题应用方法**:
```typescript
class ThemeApplier {
  apply(theme: Theme, target: HTMLElement): void {
    // 1. 设置 CSS 变量
    this.setCSSVariables(target, theme);
    
    // 2. 添加主题类名
    target.classList.add(`theme-${theme.id}`);
    
    // 3. 应用卡片特定样式
    this.applyCardStyles(target, theme);
  }
}
```

**强制要求**:
- 主题切换必须在100ms内完成
- 不得硬编码颜色值，必须使用CSS变量
- 主题文件必须包含完整的颜色定义

#### 19.1.3 性能优化规范

**虚拟滚动**:
```typescript
// ✅ 必须：长列表使用虚拟滚动
class CardListRenderer {
  render(cards: Card[], container: HTMLElement): void {
    if (cards.length > 50) {  // 超过50项使用虚拟滚动
      this.renderWithVirtualScroll(cards, container);
    } else {
      this.renderAll(cards, container);
    }
  }
}
```

**懒加载**:
```typescript
// ✅ 必须：图片和视频懒加载
class ImageCardRenderer {
  render(card: ImageCard, container: HTMLElement): Promise<RenderResult> {
    const img = document.createElement('img');
    img.loading = 'lazy';  // 必须启用懒加载
    img.src = card.url;
    // ...
  }
}
```

**性能指标**:
- 单个卡片渲染时间：<50ms (P95)
- 列表渲染帧率：≥60fps
- 主题切换延迟：<100ms
- 内存占用：单卡片<5MB

### 19.2 插件系统规范

#### 19.2.1 查看工具插件接口规范

**插件清单结构**:
```json
{
  "id": "com.example.my-viewer",
  "name": "My Viewer Plugin",
  "version": "1.0.0",
  "type": "viewer-tool",
  "supportedTypes": ["video/mp4", "video/webm"],
  "main": "dist/index.js",
  "permissions": ["fileSystem.read", "network.fetch"]
}
```

**必需字段检查**:
- `id`: 唯一标识符，必须使用反向域名格式
- `name`: 显示名称，不超过50字符
- `version`: 语义化版本号
- `type`: 必须为 `viewer-tool`
- `supportedTypes`: 至少包含一个MIME类型
- `main`: 入口文件路径

**插件接口实现**:
```typescript
// ✅ 正确：完整实现接口
export default class MyViewerPlugin implements IViewerToolPlugin {
  readonly manifest: PluginManifest;
  
  async init(context: PluginContext): Promise<void> {
    // 初始化逻辑
    this.context = context;
    this.context.logger.info(t('i18n.plugin.001'));
  }
  
  async destroy(): Promise<void> {
    // 清理资源
    this.dispose();
  }
  
  canHandle(file: FileInfo): boolean {
    return this.manifest.supportedTypes!.includes(file.mimeType);
  }
  
  async render(file: FileInfo, container: HTMLElement, options?: RenderOptions): Promise<RenderResult> {
    // 渲染逻辑
  }
  
  dispose(): void {
    // 释放资源
  }
}
```

#### 19.2.2 插件加载和卸载规范

**加载顺序**:
1. 读取并验证 manifest.json
2. 检查依赖和权限
3. 加载插件代码
4. 创建插件实例
5. 调用 init() 初始化
6. 注册到插件管理器

**卸载流程**:
```typescript
async uninstall(pluginId: string): Promise<void> {
  const plugin = this.plugins.get(pluginId);
  
  // 1. 调用 destroy
  await plugin.instance.destroy();
  
  // 2. 从注册表移除
  this.unregisterPlugin(pluginId);
  
  // 3. 清理文件
  await this.deletePluginFiles(plugin.path);
  
  // 4. 触发事件
  this.emit('plugin-uninstalled', pluginId);
}
```

**错误处理**:
- 插件加载失败不应影响主应用
- 必须记录详细的错误日志
- 向用户显示友好的错误信息

#### 19.2.3 插件沙箱规范

**权限控制**:
```typescript
enum PluginPermission {
  FILE_SYSTEM_READ = 'fileSystem.read',
  FILE_SYSTEM_WRITE = 'fileSystem.write',
  NETWORK_FETCH = 'network.fetch',
  STORAGE_LOCAL = 'storage.local',
}
```

**沙箱限制**:
- 禁止访问 `eval` 和 `Function` 构造器
- 禁止直接访问 DOM (除了提供的容器)
- 网络请求必须通过代理
- 文件访问仅限于插件目录

**安全检查**:
```typescript
// ✅ 必须：检查权限
private checkPermission(pluginId: string, permission: PluginPermission): void {
  if (!this.permissionManager.hasPermission(pluginId, permission)) {
    throw new PermissionDeniedError(
      t('i18n.error.030001', { permission })
    );
  }
}
```

### 19.3 开源组件集成规范

#### 19.3.1 Video.js集成规范

**版本要求**:
- Video.js: ^8.0.0
- 许可证: Apache 2.0

**标准配置**:
```typescript
const playerOptions = {
  controls: true,
  autoplay: false,
  preload: 'auto',
  fluid: true,
  playbackRates: [0.5, 0.75, 1, 1.25, 1.5, 2],
  language: 'zh-CN'
};
```

**错误处理**:
```typescript
player.on('error', () => {
  const error = player.error();
  logger.error(t('i18n.video.error'), { code: error.code });
  this.showErrorMessage(t('i18n.video.error.user'));
});
```

**资源清理**:
```typescript
// ✅ 必须：销毁播放器
dispose(): void {
  if (this.player) {
    this.player.dispose();
    this.player = null;
  }
}
```

#### 19.3.2 Howler.js集成规范

**版本要求**:
- Howler.js: ^2.2.0
- 许可证: MIT

**标准配置**:
```typescript
const sound = new Howl({
  src: ['audio.mp3', 'audio.ogg'],  // 提供多格式
  html5: true,  // 大文件使用HTML5模式
  preload: true,
  onloaderror: (id, error) => {
    logger.error(t('i18n.audio.load.error'), { error });
  }
});
```

**内存管理**:
```typescript
// ✅ 必须：卸载音频
dispose(): void {
  if (this.sound) {
    this.sound.unload();
    this.sound = null;
  }
}
```

#### 19.3.3 组件版本管理规范

**依赖声明**:
```json
{
  "dependencies": {
    "video.js": "^8.6.1",
    "howler": "^2.2.4",
    "viewerjs": "^1.11.6",
    "prismjs": "^1.29.0"
  }
}
```

**版本更新策略**:
- 主版本更新：需完整测试和评审
- 次版本更新：测试核心功能后更新
- 补丁更新：可自动更新
- 安全更新：立即更新

**许可证合规**:
```typescript
// 必须：在应用中声明使用的开源组件
export const OPEN_SOURCE_LICENSES = [
  {
    name: 'Video.js',
    version: '8.6.1',
    license: 'Apache-2.0',
    url: 'https://github.com/videojs/video.js'
  },
  // ... 更多组件
];
```

### 19.4 性能规范

#### 19.4.1 渲染性能要求

**性能指标**:
- 首次渲染: <200ms
- 卡片切换: <100ms
- 滚动帧率: ≥60fps
- 内存占用: 单卡片<5MB

**监控和优化**:
```typescript
// ✅ 必须：性能监控
class PerformanceMonitor {
  measureRenderTime(card: Card): void {
    const start = performance.now();
    
    // 渲染逻辑
    
    const duration = performance.now() - start;
    if (duration > 50) {  // 超过50ms记录警告
      logger.warn(t('i18n.perf.slow'), { cardId: card.id, duration });
    }
  }
}
```

#### 19.4.2 大文件处理

**分片加载**:
```typescript
// ✅ 必须：大文件分片处理
async loadLargeFile(file: FileInfo): Promise<void> {
  const CHUNK_SIZE = 1024 * 1024;  // 1MB
  
  if (file.size > CHUNK_SIZE) {
    // 使用分片加载
    await this.loadInChunks(file, CHUNK_SIZE);
  } else {
    await this.loadDirect(file);
  }
}
```

**流式处理**:
```typescript
// ✅ 推荐：使用流式API
async processLargeVideo(url: string): Promise<void> {
  const response = await fetch(url);
  const reader = response.body!.getReader();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    // 处理数据块
    await this.processChunk(value);
  }
}
```

#### 19.4.3 内存优化

**资源释放**:
```typescript
// ✅ 必须：及时释放资源
class CardRenderer {
  private observers: ResizeObserver[] = [];
  private timers: number[] = [];
  
  dispose(): void {
    // 清理观察器
    this.observers.forEach(o => o.disconnect());
    this.observers = [];
    
    // 清理定时器
    this.timers.forEach(t => clearTimeout(t));
    this.timers = [];
    
    // 清理事件监听
    this.removeAllListeners();
  }
}
```

**缓存策略**:
```typescript
// ✅ 必须：限制缓存大小
class RenderCache {
  private maxSize: number = 100;  // 最多缓存100个
  private maxMemory: number = 100 * 1024 * 1024;  // 100MB
  
  set(key: string, value: any): void {
    // 检查大小限制
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }
    
    // 检查内存限制
    if (this.getTotalSize() >= this.maxMemory) {
      this.evictLargest();
    }
    
    this.cache.set(key, value);
  }
}
```

---

## 20. 审查清单（查看器专用）

**提交前必须检查**:

**渲染相关**:
- [ ] 所有卡片类型都有对应的渲染器
- [ ] 渲染器正确实现 `ICardRenderer` 接口
- [ ] 使用CSS变量而非硬编码颜色
- [ ] 大列表启用虚拟滚动
- [ ] 图片/视频启用懒加载

**插件相关**:
- [ ] 插件清单包含所有必需字段
- [ ] 正确实现 `IViewerToolPlugin` 接口
- [ ] 插件错误不影响主应用
- [ ] 正确声明和检查权限
- [ ] 实现完整的生命周期方法

**开源组件**:
- [ ] 使用指定版本的开源组件
- [ ] 正确处理组件错误
- [ ] 及时释放组件资源
- [ ] 在应用中声明许可证

**性能相关**:
- [ ] 渲染时间符合性能指标
- [ ] 大文件使用分片加载
- [ ] 正确释放所有资源
- [ ] 缓存大小受到限制

**文档维护者**: Chips生态团队  
**最后审核**: 2026-01-30  
**状态**: ✅ 生效
